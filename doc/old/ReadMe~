
  USF Encoding rules



	'aaaa'   Push an atom onto the stack
	         (within an atom ' must be escaped (\')

	"aaa"    Push a string on the stack
	         (within a  string " must be escaped (\")

	~aaaa~   Push a binary on the stack
	         (within a binary ~ must be escaped thus (\~)

	%....%   Comment (skip)

        [-][0-9]* Integer

	\s\n\r\t,  Ignore

	#        Push nil onto the stack

	&        Replace the two topmost entries on the stack
		 with (cons X Y)

	{        Make a new stack frame

	}        Pop the topmost stack frame and convert it to 
		 a tuple (with it's element reversed)

        $        Return the top stack entry (the stack must only have
		 ONE entry now)

        Control = '"~%-0123456789{}#&$> (21 characters)

	>C       Pop the stack and store in register[C]
		 C is any character except Control

        C        Push register[C] on the stack


   Thus 'person'>p # {p,"Joe",123} & {p, 'fred', ~abc~} & $

   Represents the Erlang term

	[{person, "Joe", 123},
	 {person, fred, <<abc>>}].

   Servers and Introspection

   1) Servers only understad USF formatted messages:
   
   2) Servers always respond to
      The message 'interface'$

   3) Client Server RCP is as follows
 
      {rpc, Term} -> {reply, Reply, NextServerState}

      All terms are USF encoded.
s

      
