<include>layout.mac</include>
<top/>

<article title="White paper"
	 date="2002-03-05"
	 link=""
	 linktitle="">

<p>UBF is a language for transporting and describing complex data structures across a netwrk. It has two components:
<ul>
<li>
<b>UBF(A)</b> is a data transport format, roughtly equivalent to well-formed XML.
<li><b>UBF(B)</b> is a type system and protocol description language roughly equavalent to to Verified XML, XML-schemas, SOAP and WDSL.
</ul>

<p>While the XML series of languages had the goal of having a human
readable format the UBF langauges take the opposite view and provide a
"machine friendly" format.

<p>UBF is designed to be easy to implement. As a proof of concept - UBF drivers
For Erlang, Oz, Java and TCL can be found in the download area. 
Implementors are welcome to add new languages.

<p>UBF is designed to be "language neutral" - UBF(A) defines a
langauge neutral binary format for transporting data acroess a
network. UBF(B) is a type system for describing client/server
interactions which use UBF(A).

<h3>Prograaming by Contract</h3>
<center>
<img  src="$ROOT/images/ubf.gif">
</center>

<p>Central to UBF is the idea of a "contract" which regulates the
set of legal conversaions that can take place bnetween a client and a server.

<p>A sotware component (the contract cheker) is place between a cleint and server which checks that all interactions between thew client and server are legal.

<p>The digram shows a Java client talking to a C++ server.

<h3>UBF(A)</h3>

UBF(A) is the transport format, it was designed to be easy to parse
and to be easy to write with a text editor. UBF(A) is based on a byte
encoded virtial machine, 26 byte codes are reserved. Instead of
allocating the bye codes from 0 we use the printable character codes
to make the format easy to read.

<h3>primitive types</h3>

<p>UBF(A) has four primitave types, when a priomitve tag is recognised
it is pushed onto the "recognition stack" in our decoder. The
primitibve tyopes are:

<dl>
<dt><b>Integers</b>

<dd>Integers are sequencs of bytes whiuch could be described by the
regular expression <tt>[-][0-9]+</tt>, that is an optional minus (to
denote a negative integer) and then a sequence of at least one digits.
No restrictions are made as to the precision of the integer, precision
issues will be dealt with in UBF(B).

<dt><b>Strings</b>
<dd>Strings are written enclosed in double quotes, thus:
<pre>
   "...."
</pre>
<p>Within a string two quoting convenions are observed,
<tt>"</tt> must be written <tt>\"</tt> and <tt>\</tt> must be written
<tt>\\</tt> - no other quotings are allowed (this is so we can write a double quote <i>within</i> a string.

<dt><b>Binary Data</b>
<dd>Uninterpreted blocks of binary data are encoded, thus:
<pre>
    Int ~....~
</pre>

<p>First an integer, representing the length of the binary data is
encoded, this is followed by a tilde, the data itself which must be exactly the
length given in the integer and than a closeing tilde. The closing tilde
has no significance and is retained for readability. Whuite space can be
added Between the integer length and the data for readability.

<dt><b>Atoms</b>
<dd>Atoms are encoded as strings, only useing a single quote
instead of a double quote.

<p>Atoms are commonoly form in symbolic languages like lisp, prolog or
Erlang.  In C they would be represented by hashed strings. Teh
essential property of an atom is that two atoms can be compared for
equality in copntsnt time. These are used for representying
symbolic constants.
</dl>

<p>ZIn addition any item can be followed by a <i>semantic tag</i> this is
written <tt>`...`</tt> - with in the tag the close quoite is quoted as in the strings encoding. This tag has no meaning in UBF(A) but might have a maning in UBF(B). For example:
<pre>
    12456 ~....~ `jpg`
</pre>

<p>Represents 12456 bytes of raw data with the sematic tag "jpg".
UBF(A) does not know what "jpg" means - this is passed on to UBF(B)
which might kniow what it means - finnaly the end application is
expected to know what to do with an objeect of type "jpg", it might
foir example know that this represents an image. UBF(A) will just
encode the tag, UBF(B) will type check the tag, and the applicatioin
should be ablke to unserstand the tag.

<h3>Compound types</h3>

<p>Having defined our four simple type we define two type of "glue"
for making compounts objects.

<dl>
<dt><b>Structs</b>
<dd>Structures are written:
<pre>
    { Obj1 Obj2 ... Objn }
</pre>
<p>The byte codes for "{" and "}" are used to delimit a structure.
<tt>Obj1..Objn</tt> are arbitrary UBF(A) objects. The decoder and encoder
must map UBF(A) objects onto ann approipriate represnetaion in the
applictaion programming language (for example structs in C, arrays
in java, tuples in Erklang etc.).

<p>Structs are used to represent <i>Fixed numnbers of objects</i>

<dt><b>Lists</b>
<dd> Lists are used to represent <i>varaible numbers of objects</i>. Thet are writte with the syntax:
<pre>
    # ObjN & ObjN-1 & ... & Obj2 & Obj1
</pre>

<p> This reprents a list of objects - the first object in the list in
<tt>Obj1</tt> the second <tt>Obj2</tt> etc.- Noite that the objects
are prsented in reverse order. Lisp programmers will reconnise <tt>#</tt>
as an operator that pushes NIL (or end of list) onto the recognition stack
and <tt>&</tt> as an operator that taks the top two items on the recognition stack and replaces them by a list cell.
</dl>

<p>Finally we need to know when an object has finished.
The operator <tt>$</tt> signifies "end of object". When <tt>$</tt> is encountered there should be only one item on the recogbnition stack.

<h3>Whuite space</h3>

<p>For convenientce blank, carriage rteun, line feed tab and comma
are trated as white space. Comments can be included in UBF(A) withg the
syntax <tt>%...%</tt> the usal quoting convention applies.

<h3>Caching optimisations</h3>

So far we have used exactly 26 contrrl, chacatcters, namely:

<pre>
  %"~'`{}#&\s\n\t\r,-01234567890
</pre>

<p>This leaves us with 230 unallocated byte codes. These are used as follows:
First byte code sequence
<pre>
    &gt;C
</pre>

Where <tt>C</tt> is not one of the reserved byte codes or <tt>&gt;</tt>
means store the top of the recognition stack in the register
<tt>reg[C]</tt> and pop the recognition stack.

<p>Subsequent reuse of the single character <b>C</b>Z means
"push <tt>reg[C]</tt> onto the recognition stack"

</article>
<bot/>






