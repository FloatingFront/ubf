<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>UBF User’s Guide 1st DRAFT</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /></head><body><div xml:lang="en" class="article" title="UBF User’s Guide 1st DRAFT" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="idp9806336"></a>UBF User’s Guide <span class="emphasis"><em>1st DRAFT</em></span></h2></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="2"><strong>Revision History</strong></th></tr><tr><td align="left">Revision 0.3.7</td><td align="left">2012/08/02</td></tr></table></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#_preface">1. Preface</a></span></dt><dt><span class="section"><a href="#_introduction">2. Introduction</a></span></dt><dt><span class="section"><a href="#_specifications">3. Specifications</a></span></dt><dd><dl><dt><span class="section"><a href="#UBFa">3.1. UBF(a)</a></span></dt><dt><span class="section"><a href="#_ubf_b">3.2. UBF(b)</a></span></dt><dt><span class="section"><a href="#_ubf_c">3.3. UBF(c)</a></span></dt></dl></dd><dt><span class="section"><a href="#_contracts_amp_plugins">4. Contracts &amp; Plugins</a></span></dt><dd><dl><dt><span class="section"><a href="#_contract">4.1. Contract</a></span></dt><dt><span class="section"><a href="#_plugin">4.2. Plugin</a></span></dt><dt><span class="section"><a href="#_importing_types">4.3. Importing Types</a></span></dt><dt><span class="section"><a href="#_compilation_errors">4.4. Compilation Errors</a></span></dt><dt><span class="section"><a href="#_miscellaneous">4.5. Miscellaneous</a></span></dt></dl></dd><dt><span class="section"><a href="#_transports">5. Transports</a></span></dt><dd><dl><dt><span class="section"><a href="#_tcp_ip">5.1. TCP/IP</a></span></dt><dt><span class="section"><a href="#_http">5.2. HTTP</a></span></dt><dt><span class="section"><a href="#_miscellaneous_3">5.3. Miscellaneous</a></span></dt></dl></dd><dt><span class="section"><a href="#Servers">6. Servers</a></span></dt><dd><dl><dt><span class="section"><a href="#_stateless">6.1. Stateless</a></span></dt><dt><span class="section"><a href="#_stateful">6.2. Stateful</a></span></dt></dl></dd><dt><span class="section"><a href="#_clients">7. Clients</a></span></dt><dd><dl><dt><span class="section"><a href="#_erlang">7.1. Erlang</a></span></dt><dt><span class="section"><a href="#_python">7.2. Python</a></span></dt><dt><span class="section"><a href="#_java">7.3. Java</a></span></dt></dl></dd><dt><span class="section"><a href="#_miscellaneous_4">8. Miscellaneous</a></span></dt><dd><dl><dt><span class="section"><a href="#_testing">8.1. Testing</a></span></dt><dt><span class="section"><a href="#_utilities">8.2. Utilities</a></span></dt></dl></dd><dt><span class="section"><a href="#_building_ubf_from_source_option_1">9. Building UBF from Source - Option 1</a></span></dt><dt><span class="section"><a href="#_building_ubf_from_source_option_2">10. Building UBF from Source - Option 2</a></span></dt><dd><dl><dt><span class="section"><a href="#DOWNLOAD">10.1. Download</a></span></dt><dt><span class="section"><a href="#BUILD">10.2. Build - Mandatory</a></span></dt><dt><span class="section"><a href="#_build_optional">10.3. Build - Optional</a></span></dt><dt><span class="section"><a href="#UBFAsciiDoc">10.4. UBF Documentation</a></span></dt><dt><span class="section"><a href="#ErlangOTP">10.5. Erlang/OTP System</a></span></dt><dt><span class="section"><a href="#_github_forking_your_own_repositories">10.6. GitHub - Forking Your Own Repositories</a></span></dt></dl></dd><dt><span class="section"><a href="#_reference">11. Reference</a></span></dt><dt><span class="section"><a href="#_appendix">12. Appendix</a></span></dt><dd><dl><dt><span class="section"><a href="#_acknowledgments">12.1. Acknowledgments</a></span></dt><dt><span class="section"><a href="#_abnf_definition">12.2. ABNF Definition</a></span></dt></dl></dd></dl></div><p></p><div class="section" title="1. Preface"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_preface"></a>1. Preface</h2></div></div></div><p>UBF is a framework that permits the Erlang to talk to the outside
world <a class="xref" href="#UBFPAPER">[UBFPAPER]</a>.  The acronym "UBF" stands for "Universal Binary
Format", designed and implemented by Joe Armstrong.</p><p>This document and the corresponding open-source code repositories
hosted on github <a class="xref" href="#UBF">[UBF]</a> are based on Joe Armstrong’s original UBF
site <a class="xref" href="#UBFSITE">[UBFSITE]</a> and UBF code with an MIT license file added to the
distribution.  Since then, a large number of enhancements and
improvements have been added.</p></div><div class="section" title="2. Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_introduction"></a>2. Introduction</h2></div></div></div><p>UBF is a language for transporting and describing complex data
structures across a network.  It has three components:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
UBF(a) is a "language neutral" data transport format, roughly
  equivalent to well-formed XML.
</li><li class="listitem">
UBF(b) is a programming language for describing types in UBF(a) and
  protocols between clients and servers.  This layer is typically
  called the "protocol contract".  UBF(b) is roughly equivalent to
  Verified XML, XML-schemas, SOAP and WDSL.
</li><li class="listitem">
UBF(c) is a meta-level protocol used between a UBF client and a UBF
  server.
</li></ul></div><p>While the XML series of languages had the goal of having a human
readable format the UBF languages take the opposite view and provide a
"machine friendly" format.  UBF is designed to be easy to implement.</p><div class="figure"><a id="idp9818800"></a><p class="title"><strong>Figure 1. Programming By Contract</strong></p><div class="figure-contents"><a class="ulink" href="images/ubf-flow-01.svg" target="_top">
  <div class="mediaobject"><img src="images/ubf-flow-01.png" alt="Programming By Contract" /></div>
</a></div></div><br class="figure-break" /><p>Central to UBF is the idea of a "Contract" which regulates the set of
legal conversations that can take place between a client and a server.
The client-side is depicted in "red" and the server-side is depicted
in "blue".  The client and server communicate with each other via a
TCP/IP connection.  All data sent by both the client and the server is
verified by the "Contract Manager" (an Erlang process on the "server"
side of the protocol).  Any data that violates the contract is
rejected.</p><p>The UBF framework itself is designed to be easy to extend for
supporting other data transport formats and other network transports.
For example, JSON, Thrift, and Erlang native binary serialization data
formats over TCP/IP and JSON-RPC over HTTP are supported alternatives
to the original UBF(a) implementation.</p><p></p></div><div class="section" title="3. Specifications"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_specifications"></a>3. Specifications</h2></div></div></div><div class="section" title="3.1. UBF(a)"><div class="titlepage"><div><div><h3 class="title"><a id="UBFa"></a>3.1. UBF(a)</h3></div></div></div><p>UBF(a) is a transport format.  UBF(a) was designed to be easy to parse
and to be easy to write with a text editor.  UBF(a) is based on a byte
encoded virtual machine, 26 byte codes are reserved.  Instead of
allocating the byte codes from 0, the printable character codes are
used to make the format easy to read.</p><p>UBF(a) has four primitive types, when a primitive type is recognized
it is pushed onto the "recognition stack" in our decoder.  The
primitive types are Integer, String, Binary, and Atom.  UBF(a) has two
types of "glue" for making compound objects.  The compound types are
Tuple and List.  Lastly, the operator <span class="emphasis"><em>$</em></span> (i.e. "end of object")
signifies when objects are finished.</p><p>For example, the following UBF(a) object:</p><pre class="screen">'person'&gt;p # {p "Joe" 123} &amp; {p 'fred' 3~abc~} &amp; $</pre><p>Represents the following UBF(b) term, a list that contains two
3-tuples:</p><pre class="screen">[{'person', 'fred', &lt;&lt;"abc"&gt;&gt;}, {'person', "Joe", 123}].</pre><div class="tip" title="Tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>In UBF(a), white space as well as commas are treated as a
delimiter.</p></td></tr></table></div><p>For this example, the recognition stack for parsing this UBF(a) object
would be as follows:</p><pre class="screen">    'person'&gt;p # {p "Joe" 123} &amp; {p 'fred', 3~abc~} &amp; $
             ^ ^ ^^     ^   ^^ ^                  ^ ^ ^
             | | ||     |   || |                  | | |

             1 2 ab     c   d3 4                  5 6 7

Time  Stack

1   'person'

2   []

2a  { ... incomplete
    []

2b  {'person' ... incomplete
    []

2c  {'person', "Joe",  ... incomplete
    []

2d  {'person', "Joe", 123 ... incomplete}
    []

3   {'person', "Joe", 123}
    []

4   [{'person', "Joe", 123}]

5   {'person', 'fred', &lt;&lt;"abc"&gt;&gt;}
    [{'person', "Joe", 123}]

6   [{'person', 'fred', &lt;&lt;"abc"&gt;&gt;}, {'person', "Joe", 123}]

7   [{'person', 'fred', &lt;&lt;"abc"&gt;&gt;}, {'person', "Joe", 123}]</pre><p>See <a class="xref" href="#ABNF-UBFa" title="UBF(a)">the section called “UBF(a)”</a> for a formal definition of the UBF(a) syntax.</p><div class="caution" title="Caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>There is no "Float" primitive type in the original and
current UBF(a) implementation.  After Joe Armstrong’s original
implementation, a "Float" type was added to UBF(b) for use in other
network transports other than UBF(a).  In future, UBF(a) could be
enhanced to support a "Float" primitive type.</p></td></tr></table></div><div class="section" title="Integer: [-][0-9]+"><div class="titlepage"><div><div><h4 class="title"><a id="_integer_0_9"></a>Integer: [-][0-9]+</h4></div></div></div><p>Integers are sequences of bytes which could be described by the
regular expression [-][0-9]+, that is an optional minus (to denote a
negative integer) and then a sequence of at least one digit.</p></div><div class="section" title="String: &quot;…&quot;"><div class="titlepage"><div><div><h4 class="title"><a id="_string_8230"></a>String: "…"</h4></div></div></div><p>Strings are written enclosed in double quotes.  Within a string two
quoting conventions are observed, " must be written \" and \ must be
written \\ - no other quotings are allowed.</p></div><div class="section" title="Binary: [0-9]+ ~…~"><div class="titlepage"><div><div><h4 class="title"><a id="_binary_0_9_8230"></a>Binary: [0-9]+ ~…~</h4></div></div></div><p>Uninterpreted blocks of binary data are encoded.  First an integer,
representing the length of the binary data is encoded, this is
followed by a tilde, the data itself which must be exactly the length
given in the integer and than a closing tilde.  The closing tilde has
no significance and is retained for readability.  White space can be
added between the integer length and the data for readability.</p></div><div class="section" title="Atom: '…'"><div class="titlepage"><div><div><h4 class="title"><a id="_atom_8230"></a>Atom: '…'</h4></div></div></div><p>Atoms are encoded as strings, only using a single quote instead of a
double quote.  Atoms are commonly found in symbolic languages like
Lisp, Prolog or Erlang.  In C, they would be represented by hashed
strings.  The essential property of an atom is that two atoms can be
compared for equality in constant time.  These are used for
representing symbolic constants.</p></div><div class="section" title="Tuple: { Obj1 Obj2 … ObjN-1 ObjN }"><div class="titlepage"><div><div><h4 class="title"><a id="_tuple_obj1_obj2_8230_objn_1_objn"></a>Tuple: { Obj1 Obj2 … ObjN-1 ObjN }</h4></div></div></div><p>Tuples represent <span class="emphasis"><em>fixed numbers</em></span> of objects.  The byte codes for "{"
and "}" are used to delimit a tuple. Obj1, Obj2, ObjN-1, and ObjN are
arbitrary UBF(a) objects.</p></div><div class="section" title="List: # ObjN &amp; ObjN-1 &amp; … &amp; Obj2 &amp; Obj1"><div class="titlepage"><div><div><h4 class="title"><a id="_list_objn_amp_objn_1_amp_8230_amp_obj2_amp_obj1"></a>List: # ObjN &amp; ObjN-1 &amp; … &amp; Obj2 &amp; Obj1</h4></div></div></div><p>Lists represent <span class="emphasis"><em>variable numbers</em></span> of objects.  The first object in
the list is Obj1, the second object in the list is Obj2, etc.  Objects
are presented in reverse order.</p><p>Lisp programmers will recognize <span class="emphasis"><em>#</em></span> as an operator that pushes NIL (or
the end of list) onto the recognition stack and <span class="emphasis"><em>&amp;</em></span> as an operator
that takes the top two items on the recognition stack and replaces
them by a list cell.</p></div><div class="section" title="Term"><div class="titlepage"><div><div><h4 class="title"><a id="_term"></a>Term</h4></div></div></div><p>Terms represent primitive types and compound types.</p></div><div class="section" title="White space: \s \n \r \t , %…%"><div class="titlepage"><div><div><h4 class="title"><a id="_white_space_s_n_r_t_8230"></a>White space: \s \n \r \t , %…%</h4></div></div></div><p>For convenience, blank, carriage return, line feed, tab, comma, and
comments are treated as white space.  Comments can be included in
UBF(a) with the syntax %…% and the usual quoting convention applies.</p></div><div class="section" title="Tag: `…`"><div class="titlepage"><div><div><h4 class="title"><a id="_tag_8230"></a>Tag: `…`</h4></div></div></div><p>In addition any item can be followed by a semantic tag this is written
`…` - with in the tag the close quote is quoted as in the strings
encoding.  This tag has no meaning in UBF(a) but might have a meaning
in UBF(b).  For example:</p><pre class="screen">12456 ~...~ `jpg`</pre><p>Represents 12,456 bytes of raw data with the semantic tag "jpg".
UBF(a) does not know what "jpg" means - this is passed on to UBF(b)
which might know what it means - finally the end application is
expected to know what to do with an object of type "jpg", it might for
example know that this represents an image.  UBF(a) will just encode
the tag, UBF(b) will type check the tag, and the application should be
able to understand the tag.</p><div class="caution" title="Caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Currently, this feature of integrating a "tag" in UBF(a) for
the purpose of a "type" in UBF(b) is not implemented.  Tags can be
specified in UBF(a) but there is no way for the application to act
upon this semantic information.</p></td></tr></table></div></div><div class="section" title="Register: &gt;C C"><div class="titlepage"><div><div><h4 class="title"><a id="_register_gt_c_c"></a>Register: &gt;C C</h4></div></div></div><p>So far, exactly 26 control characters have been used, namely:
%"~'`{}#&amp;\s\n\t\r,-01234567890</p><p>This leaves us with 230 unallocated byte codes.  These are used as
follows:</p><pre class="screen">&gt;C</pre><p>Where <span class="emphasis"><em>C</em></span> is not one of the reserved byte codes, &gt; means store the top
of the recognition stack in the register <span class="emphasis"><em>C</em></span> and pop the recognition
stack.  For caching optimizations, subsequent reuse of the single
character <span class="emphasis"><em>C</em></span> means push register <span class="emphasis"><em>C</em></span> onto the recognition stack.</p></div><div class="section" title="Object"><div class="titlepage"><div><div><h4 class="title"><a id="_object"></a>Object</h4></div></div></div><p>Objects represent either a Term, a Register push, or a Register pop
with an optional Tag.  The operator <span class="emphasis"><em>$</em></span> signifies "end of object".
When <span class="emphasis"><em>$</em></span> is encountered there should be only one item on the
recognition stack.</p></div></div><div class="section" title="3.2. UBF(b)"><div class="titlepage"><div><div><h3 class="title"><a id="_ubf_b"></a>3.2. UBF(b)</h3></div></div></div><p>UBF(b) is a language independent type system and protocol description
language.  The protocol description language allows one to specify
client server interaction in terms of a non-deterministic finite state
machine.  The type system allows one to specify the asynchronous
events and synchronous request/response pairs that define transitions
of this finite state machine.</p><p>The type system and protocol description language together define the
basis of "Contracts" between clients and servers.  All data sent by
both the client and the server is verified by the "Contract Manager"
(an Erlang process on the "server" side of the protocol).  Any data
that violates the contract is rejected.</p><p>A UBF(b) contract is defined by 2 mandatory sections and 3 optional
sections.  The mandatory sections are the "+NAME" and the "+VERSION"
of the contract.  The optional sections are the "+TYPES", the
"+STATE", and the "+ANYSTATE" of the contract.</p><p>For example, the following UBF(b) contract having the filename
"irc_plugin.con" defines a simple IRC (Internet Relay Chat) protocol
between clients and a server:</p><pre class="programlisting">+NAME("irc").

+VSN("ubf1.0").

+TYPES
info()            = info;
description()     = description;
contract()        = contract;

ok()              = ok;
bool()            = true | false;
nick()            = string();
oldnick()         = nick();
newnick()         = nick();
group()           = string();
groups()          = [group()];

logon()           = logon;
proceed()         = {ok, nick()};
listGroups()      = groups;
joinGroup()       = {join, group()};
leaveGroup()      = {leave, group()};
changeNick()      = {nick, nick()};
msg()             = {msg, group(), string()};

msgEvent()        = {msg, nick(), group(), string()};
joinEvent()       = {joins, nick(), group()};
leaveEvent()      = {leaves, nick(), group()};
changeNameEvent() = {changesName, oldnick(), newnick(), group()}.

+STATE start
   logon()       =&gt; proceed() &amp; active. %% Nick randomly assigned

+STATE active
   listGroups()  =&gt; groups() &amp; active;
   joinGroup()   =&gt; ok() &amp; active;
   leaveGroup()  =&gt; ok() &amp; active;
   changeNick()  =&gt; bool() &amp; active;
   msg()         =&gt; bool() &amp; active;    %% False if you have not joined a group

   EVENT         =&gt; msgEvent();         %% Group sends me a message
   EVENT         =&gt; joinEvent();        %% Nick joins group
   EVENT         =&gt; leaveEvent();       %% Nick leaves group
   EVENT         =&gt; changeNameEvent().  %% Nick changes name

+ANYSTATE
   info()        =&gt; string();
   description() =&gt; string();
   contract()    =&gt; term().</pre><p>See <a class="xref" href="#ABNF-UBFb" title="UBF(b)">the section called “UBF(b)”</a> for a formal definition of the UBF(b) syntax.</p><div class="note" title="Note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The astute reader (and otherwise :) ) may notice that UBF(a) and
UBF(b) are Erlang-centric.  By design, the two languages are supposed
to be language neutral and yet <span class="emphasis"><em>by design</em></span> the two are highly
influenced by Erlang.  For example, the difference between a string
type and a binary type is directly due to Erlang’s implementation of
binaries and strings.  Similarly, the reason for supporting a record
type and extended record type is also directly due to Erlang’s
implementation of records.</p></td></tr></table></div><div class="section" title="Name: +NAME(&quot;…&quot;)."><div class="titlepage"><div><div><h4 class="title"><a id="_name_name_8230"></a>Name: +NAME("…").</h4></div></div></div><p>The name of the contract is specified as a double-quoted string.</p></div><div class="section" title="Version: +VSN(&quot;…&quot;)."><div class="titlepage"><div><div><h4 class="title"><a id="_version_vsn_8230"></a>Version: +VSN("…").</h4></div></div></div><p>The version of the contract is specified as a double-quoted string.</p></div><div class="section" title="Types: +TYPES."><div class="titlepage"><div><div><h4 class="title"><a id="_types_types"></a>Types: +TYPES.</h4></div></div></div><p>The UBF(b) type system has user-defined types and predefined types.
User-defined types and predefined types are either primitive types or
complex types.</p><p>The primitive types are Integer, Range, Float, Binary, String, Atom,
and Reference.  The complex types are Alternative, Tuple, Record,
Extended Record, and List.  User-defined "complex types" are defined
recursively.</p><div class="section" title="Definition: X() = T"><div class="titlepage"><div><div><h5 class="title"><a id="_definition_x_t"></a>Definition: X() = T</h5></div></div></div><p>New types are defined by the notation:</p><pre class="screen">X() = T;</pre><p>and the last type of new types must be defined by the notation:</p><pre class="screen">X() = T.</pre><p>The name of the type is <span class="emphasis"><em>X</em></span> and the type’s definition <span class="emphasis"><em>T</em></span> is either a
user-defined type or a predefined type.</p></div><div class="section" title="Integer: [-][0-9]+ or [0-9]+#[0-9a-f]+"><div class="titlepage"><div><div><h5 class="title"><a id="_integer_0_9_emphasis_or_emphasis_0_9_0_9a_f"></a>Integer: [-][0-9]+ <span class="emphasis"><em>or</em></span> [0-9]+#[0-9a-f]+</h5></div></div></div><p>Positive and negative integer constants are expressed as in UBF(a).
Integer constants may also be expressed in other bases using Erlang
syntax.</p></div><div class="section" title="Range: [-][0-9]+..[-][0-9]+ or [-][0-9]+.. or ..[-][0-9]+"><div class="titlepage"><div><div><h5 class="title"><a id="_range_0_9_0_9_emphasis_or_emphasis_0_9_emphasis_or_emphasis_0_9"></a>Range: [-][0-9]+..[-][0-9]+ <span class="emphasis"><em>or</em></span> [-][0-9]+.. <span class="emphasis"><em>or</em></span> ..[-][0-9]+</h5></div></div></div><p>Bounded, left unbounded, and right unbounded integer ranges are
supported.</p></div><div class="section" title="Float: [-][0-9]+.[0-9]+"><div class="titlepage"><div><div><h5 class="title"><a id="_float_0_9_0_9"></a>Float: [-][0-9]+.[0-9]+</h5></div></div></div><p>Positive and negative float constants are supported for network
transports other than UBF(a).</p><div class="note" title="Note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>In future, the implementation of UBF(b) could be enhanced to
specify a float more compactly using scientific notation
(e.g. "6.02e23").</p></td></tr></table></div></div><div class="section" title="Binary: &lt;&lt;&quot;…&quot;&gt;&gt;"><div class="titlepage"><div><div><h5 class="title"><a id="_binary_lt_lt_8230_gt_gt"></a>Binary: &lt;&lt;"…"&gt;&gt;</h5></div></div></div><p>Binary constants are expressed similarly as strings in UBF(a) but
having two leading "less than brackets" and two following "greater
than brackets".</p></div><div class="section" title="String: &quot;…&quot;"><div class="titlepage"><div><div><h5 class="title"><a id="_string_8230_2"></a>String: "…"</h5></div></div></div><p>String constants are expressed as in UBF(a).</p></div><div class="section" title="Atom: '…' or [a-z][a-zA-Z0-9_]*"><div class="titlepage"><div><div><h5 class="title"><a id="_atom_8230_emphasis_or_emphasis_a_z_a_za_z0_9"></a>Atom: '…' <span class="emphasis"><em>or</em></span> [a-z][a-zA-Z0-9_]*</h5></div></div></div><p>Atom constants are expressed as UBF(a) atoms.  Atom constants starting
with lowercase letters do not require single quotes.</p></div><div class="section" title="Reference: R()"><div class="titlepage"><div><div><h5 class="title"><a id="_reference_r"></a>Reference: R()</h5></div></div></div><p>Defined types are referenced by the notation:</p><pre class="screen">R()</pre><p>The name of the type is <span class="emphasis"><em>R</em></span>.</p></div><div class="section" title="Alternative: T1 | T2"><div class="titlepage"><div><div><h5 class="title"><a id="_alternative_t1_t2"></a>Alternative: T1 | T2</h5></div></div></div><p>A type X is of type "T1 | T2" if X is of type T1 or if X is of type
T2.</p></div><div class="section" title="Tuple: {T1, T2, …, Tn}"><div class="titlepage"><div><div><h5 class="title"><a id="_tuple_t1_t2_8230_tn"></a>Tuple: {T1, T2, …, Tn}</h5></div></div></div><p>A type {X1, X2, …, Xn} is of type "{T1, T2, …, Tn}" if X1 is of
type T1, X2 is of type T2, … and Xn is of type Tn.</p></div><div class="section" title="Record: name#T1, y=T2, …, z=Tn"><div class="titlepage"><div><div><h5 class="title"><a id="_record_name_t1_y_t2_8230_z_tn"></a>Record: name#T1, y=T2, …, z=Tn</h5></div></div></div><p>A record type is syntactic sugar for a tuple of type "{name, T1, T2,
…, Tn}" where name, x, y, …, and z are atoms.</p></div><div class="section" title="Extended Record: name##T1, y=T2, …, z=Tn"><div class="titlepage"><div><div><h5 class="title"><a id="_extended_record_name_t1_y_t2_8230_z_tn"></a>Extended Record: name##T1, y=T2, …, z=Tn</h5></div></div></div><p>An extended record type is syntactic sugar for a tuple of type "{name,
T1, T2, …, Tn, <span class="emphasis"><em>$fields</em></span>=[x,y,…,z], <span class="emphasis"><em>$extra</em></span>=Extra}" where name,
x, y, …, and z are atoms and Extra is any valid term.</p></div><div class="section" title="List: [T]"><div class="titlepage"><div><div><h5 class="title"><a id="_list_t"></a>List: [T]</h5></div></div></div><p>A type [X1, X2, …, Xn] is of type [T] if all of Xi are of type T.</p></div><div class="section" title="Predefined: P() or P(A1, A2, …, An)"><div class="titlepage"><div><div><h5 class="title"><a id="_predefined_p_emphasis_or_emphasis_p_a1_a2_8230_an"></a>Predefined: P() <span class="emphasis"><em>or</em></span> P(A1, A2, …, An)</h5></div></div></div><p>Predefined types are referenced by the notation:</p><pre class="screen">P()</pre><p>or by the notation:</p><pre class="screen">P(A1, A2, ..., An)</pre><p>The name of the predefined type is <span class="emphasis"><em>P</em></span>.  Using the second notation,
attributes can be specified to make the predefined type less general
and thus more specific when matching objects.</p><div class="informaltable"><table cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /><col class="col_5" /></colgroup><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>ascii</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>asciiprintable</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>nonempty</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>nonundefined</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>integer</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>float</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>binary</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>string</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>atom</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>tuple</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>list</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>proplist</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>term</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>O</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>void</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>X</p></td><td style="" align="left" valign="top"><p>X</p></td></tr></tbody></table></div><p>The above table summarizes the set of supported predefined types and
their respective optional attributes.</p><p>The "integer", "float", "binary", "string", "atom", "tuple", and
"list" predefined types match directly to the corresponding primitive
or complex type.</p><p>The "term" predefined type matches any object.</p><p>The "proplist" predefined type is a specialized version of the "list"
predefined type that matches the following types:</p><pre class="screen">[{term(), term()}]</pre><p>The "void" predefined type is a placeholder to describe the return
value of a function call that does not return to the caller.</p><p>The "ascii" attribute permits matches with binaries, strings, and
atoms containing only ASCII values <a class="xref" href="#RFC20">[RFC20]</a>.  Similarly, the
"asciiprintable" attribute permits matches with only printable ASCII
values.</p><p>The "nonempty" attribute permits matches with binaries, strings,
atoms, tuples, lists, proplists, and terms that are of length greater
than zero.  The following objects would not be matched with the
"nonempty" attribute:</p><pre class="screen">&lt;&lt;""&gt;&gt;
""
''
{}
[]</pre><p>The "nonundefined" attribute permits matches with atoms and terms that
are not equal to the <span class="emphasis"><em>undefined</em></span> atom.</p><div class="note" title="Note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>By convention, the <span class="emphasis"><em>undefined</em></span> atom is commonly used to indicate
a default value or an undefined value in Erlang programs.  The purpose
of <span class="emphasis"><em>undefined</em></span> is similar to NULL in C, to None in Python, etc.</p></td></tr></table></div></div></div><div class="section" title="State: +STATE."><div class="titlepage"><div><div><h4 class="title"><a id="_state_state"></a>State: +STATE.</h4></div></div></div><p>The "+STATE" sections of UBF(b) defines a finite state machine (FSM)
to model the interaction between the client and server.  Symbolic
names expressed as "atoms" are the states of the FSM.</p><p>Transitions expressed as request, response, and next state triplets
are the edges of the FSM.  Transitions are "synchronous" calls from
the client to the server.  Any request sent by the client that cannot
match at least one valid transition is ignored and a "client broke
contract" error response is returned to the client.  Likewise, any
response returned by the server that cannot match at least one valid
transition is ignored and a "server broke contract" error response is
returned to the client.</p><p>The states of the FSM may also be annotated with events expressed as
"asynchronous" casts.  Events are asynchronous casts either from the
client to the server or from the server to the client.  Please see
next section for additional details.</p><div class="note" title="Note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The terminology of "call" and "cast" to distinguish between
synchronous and asynchronous interaction is borrowed from Erlang.</p></td></tr></table></div></div><div class="section" title="Anystate: +ANYSTATE."><div class="titlepage"><div><div><h4 class="title"><a id="_anystate_anystate"></a>Anystate: +ANYSTATE.</h4></div></div></div><p>The "+ANYSTATE" section of UBF(b) are used to define request and
response pairs and to define events that are valid in <span class="emphasis"><em>all</em></span> states of
the FSM.</p><p>Events are checked based on direction first, on the current state’s
valid events next, and finally on the valid anystate events.  Any cast
sent by the client or sent by the server that cannot match at least
one valid event is ignored and dropped.</p></div></div><div class="section" title="3.3. UBF(c)"><div class="titlepage"><div><div><h3 class="title"><a id="_ubf_c"></a>3.3. UBF(c)</h3></div></div></div><p>UBF(c) is a meta-level protocol used between a UBF client and a UBF
server.  UBF(c) has two primitives: synchronous "calls" and
asynchronous "casts".</p><div class="section" title="Calls: Request $ ⇒ {Response, NextState} $"><div class="titlepage"><div><div><h4 class="title"><a id="_calls_request_8658_response_nextstate"></a>Calls: Request $ ⇒ {Response, NextState} $</h4></div></div></div><p>Synchronous calls have the following form for the request:</p><pre class="screen">Request $</pre><p>and for the response:</p><pre class="screen">{Response, NextState} $</pre><p>where "Request" is an UBF(a) type sent by the client and "Response" is
an UBF(a) type and "NextState" is an UBF(a) atom sent by the server.</p><p>If the client sends an invalid request, the server will respond with
the following "client broke contract" error:</p><pre class="screen">{{'clientBrokeContract', Request, ExpectsIn}, State} $</pre><p>where "ExpectsIn" is a UBF(a) type to describe the acceptable list of
input types and "State" is an UBF(a) atom.</p><p>If the server sends an invalid response, the server will respond with
the following "server broke contract" error:</p><pre class="screen">{{'serverBrokeContract', Response, ExpectsOut}, State} $</pre><p>where "ExpectsOut" is a UBF(a) type to describe the acceptable list of
output types and "State" is an UBF(a) atom.</p><div class="caution" title="Caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>By convention, the 3-tuples {'clientBrokeContract', _, _}
and {'serverBrokeContract', _, _} are reserved terms for responses.
Please be careful when designing your application not to use either of
these 3-tuples.</p></td></tr></table></div></div><div class="section" title="Casts: {'event_in', Event} $ or {'event_out', Event} $"><div class="titlepage"><div><div><h4 class="title"><a id="_casts_event_in_event_emphasis_or_emphasis_event_out_event"></a>Casts: {'event_in', Event} $ <span class="emphasis"><em>or</em></span> {'event_out', Event} $</h4></div></div></div><p>Asynchronous casts from the client to server have the following form:</p><pre class="screen">{'event_in', Event} $</pre><p>and from the server to the client have the following form:</p><pre class="screen">{'event_out', Event} $</pre><p>where "Event" is an UBF(a) type.</p><p>If client or server send an invalid event, the event is ignored and
dropped by the server.</p><p>See <a class="xref" href="#ABNF-UBFc" title="UBF(c)">the section called “UBF(c)”</a> for a formal definition of the UBF(c) syntax.</p><div class="caution" title="Caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>By convention, the 2-tuples {'event_in', _} and
{'event_out', _} are reserved terms for requests and responses
respectively.  Please be careful when designing your application not
to use either of these two tuples.  This limitation introduced
unintentionally after the original UBF implementation may be removed
in the future.</p></td></tr></table></div><p></p></div></div></div><div class="section" title="4. Contracts &amp; Plugins"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_contracts_amp_plugins"></a>4. Contracts &amp; Plugins</h2></div></div></div><p>"Contracts" and "Plugins" are the basic building blocks of an Erlang
UBF server.  Contracts are a server’s specifications.  Plugins are a
server’s implementations.</p><div class="section" title="4.1. Contract"><div class="titlepage"><div><div><h3 class="title"><a id="_contract"></a>4.1. Contract</h3></div></div></div><p>A contract is a UBF(b) specification stored to a file.  By convention,
a contract’s filename has ".con" as the suffix part.  Since all
sections of a UBF(b) specification are optional except for the "+NAME"
and "+VERSION" sections, it is possible to have "+TYPES" only
contracts, "+STATE" only contracts, "+ANYSTATE" only contracts, or any
combination of such contracts.</p><p>For example, a "+TYPES" only contract having the filename
"irc_types_plugin.con" is as follows:</p><pre class="programlisting">+NAME("irc_types").

+VSN("ubf1.0").

+TYPES
info()            = info;
description()     = description;
contract()        = contract;

ok()              = ok;
bool()            = true | false;
nick()            = string();
oldnick()         = nick();
newnick()         = nick();
group()           = string();
groups()          = [group()];

logon()           = logon;
proceed()         = {ok, nick()};
listGroups()      = groups;
joinGroup()       = {join, group()};
leaveGroup()      = {leave, group()};
changeNick()      = {nick, nick()};
msg()             = {msg, group(), string()};

msgEvent()        = {msg, nick(), group(), string()};
joinEvent()       = {joins, nick(), group()};
leaveEvent()      = {leaves, nick(), group()};
changeNameEvent() = {changesName, oldnick(), newnick(), group()}.</pre><p>For example, a "+STATE" and "+ANYSTATE" contract having the filename
"irc_fsm_plugin.con" is as follows:</p><pre class="programlisting">+NAME("irc").

+VSN("ubf1.0").

+STATE start
   logon()       =&gt; proceed() &amp; active. %% Nick randomly assigned

+STATE active
   listGroups()  =&gt; groups() &amp; active;
   joinGroup()   =&gt; ok() &amp; active;
   leaveGroup()  =&gt; ok() &amp; active;
   changeNick()  =&gt; bool() &amp; active;
   msg()         =&gt; bool() &amp; active;    %% False if you have not joined a group

   EVENT         =&gt; msgEvent();         %% Group sends me a message
   EVENT         =&gt; joinEvent();        %% Nick joins group
   EVENT         =&gt; leaveEvent();       %% Nick leaves group
   EVENT         =&gt; changeNameEvent().  %% Nick changes name

+ANYSTATE
   info()        =&gt; string();
   description() =&gt; string();
   contract()    =&gt; term().</pre></div><div class="section" title="4.2. Plugin"><div class="titlepage"><div><div><h3 class="title"><a id="_plugin"></a>4.2. Plugin</h3></div></div></div><p>A plugin is just a "normal" Erlang module that follows a few simple
rules.  For a "+TYPES" only contract, the plugin contains just the
name of it’s contract.  Otherwise, the plugin contains the name of
it’s contract plus the necessary Erlang "glue code" needed to bind the
UBF server to the server’s application.  In either case, a plugin can
also import all or a subset of "+TYPES" from other plugins.  This
simple yet powerful import mechanism permits sharing and re-use of
types between plugins and servers.</p><div class="note" title="Note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The necessary Erlang "glue code" is presented later in the
<a class="xref" href="#Servers" title="6. Servers">Section 6, “Servers”</a> section.</p></td></tr></table></div><p>For the full example IRC contract described in a previous section, the
plugin having the filename "irc_plugin.erl" is as follows:</p><pre class="screen">-module(irc_plugin).

-compile({parse_transform,contract_parser}).
-add_contract("irc_plugin").</pre><p>The plugin for the "+TYPES" only contract having the filename
"irc_types_plugin.erl" is as follows:</p><pre class="screen">-module(irc_types_plugin).

-compile({parse_transform,contract_parser}).
-add_contract("irc_types_plugin").</pre></div><div class="section" title="4.3. Importing Types"><div class="titlepage"><div><div><h3 class="title"><a id="_importing_types"></a>4.3. Importing Types</h3></div></div></div><p>The plugin for the "+STATE" and "+ANYSTATE" contract having the
filename "irc_fsm_plugin.erl" is as follows:</p><pre class="screen">-module(irc_fsm_plugin).

-compile({parse_transform,contract_parser}).
-add_types(irc_types_plugin).
-add_contract("irc_fsm_plugin").</pre><p>The "-add_types('there')" directive imports all "+TYPES" from the
plugin named 'there' into the containing plugin.  An alternative
syntax "-add_types({'elsewhere', ['t1', 't2', …, 'tn']})."
for this directive imports a subset of "+TYPEs" from the plugin named
'elsewhere' into the containing plugin.  Multiple import directives
of either syntax can be freely declared as long as the "-add_types"
directives are listed before the "-add_contract" directive.  A plugin
can have only one "-add_contract" directive.</p><p>By using this Erlang "parse transform", the contract is parsed and the
imported types (if any) are processed during the compilation of the
plugin’s Erlang module.  The normal search path used by Erlang’s
compiler to locate modules is used to import types from other plugins.</p></div><div class="section" title="4.4. Compilation Errors"><div class="titlepage"><div><div><h3 class="title"><a id="_compilation_errors"></a>4.4. Compilation Errors</h3></div></div></div><p>The plugin will fail to compile if the plugin’s contract cannot be
found, cannot be parsed properly, or if one of the following errors
occurs:</p><div class="variablelist"><dl><dt><span class="term">
{'duplicated_records', L}
</span></dt><dd>
  One or more records having the same name are found.
</dd><dt><span class="term">
{'duplicated_states', L}
</span></dt><dd>
  One or more states having the same name are found.
</dd><dt><span class="term">
{'duplicated_types', L}
</span></dt><dd>
  One or more types having the same name are found.
</dd><dt><span class="term">
{'duplicated_unmatched_import_types', L}
</span></dt><dd>
  One or more imported types having the same name but different
  definitions are found.  <span class="emphasis"><em>Type duplicates are permitted as long as
  the type(s) are imported and all duplicates have the same
  definition.</em></span>
</dd><dt><span class="term">
{'missing_states', L}
</span></dt><dd>
  One or more states were found to be missing.
</dd><dt><span class="term">
{'missing_types', L}
</span></dt><dd>
  One or more types were found to be missing.
</dd><dt><span class="term">
{'unused_types', L}
</span></dt><dd>
  One or more types were found to be unused in the contract.  <span class="emphasis"><em>Unused
  types are permitted as long as the unused type(s) are imported.</em></span>
</dd></dl></div><p>where L is an Erlang list.</p></div><div class="section" title="4.5. Miscellaneous"><div class="titlepage"><div><div><h3 class="title"><a id="_miscellaneous"></a>4.5. Miscellaneous</h3></div></div></div><p>As a by-product of a plugin’s compilation and if one or more "record"
or "extended record" types were declared in a plugin’s contract, an
Erlang "header" file containing the plugin’s record definitions is
automatically created.  This Erlang "header" file can be included by
the plugin module itself or by other Erlang modules used by the
server’s application.  By convention, this Erlang "header" file has
the same base filename as the plugin but having a ".huc" as the suffix
part.</p><div class="tip" title="Tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>There are 2 experimental prototypes for extending UBF’s type and
plugin framework.  <a class="xref" href="#UBF_ABNF">[UBF_ABNF]</a> is a framework for integrating UBF and
ABNF specifications.  <a class="xref" href="#UBF_EEP8">[UBF_EEP8]</a> is a framework for integrating UBF
and EEP8 types.</p></td></tr></table></div><p></p></div></div><div class="section" title="5. Transports"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_transports"></a>5. Transports</h2></div></div></div><p>The original "UBF" network transport is UBF(a) over TCP/IP.  Since
then, a number of new transports <span class="strong"><strong>not</strong></span> based on UBF(a) and not based
on TCP/IP have been added.  Nevertheless, these transports are still
considered as part of the overall UBF framework.  Most importantly,
applications can share and re-use the same UBF contracts and plugins
irregardless of the network transport.</p><div class="section" title="5.1. TCP/IP"><div class="titlepage"><div><div><h3 class="title"><a id="_tcp_ip"></a>5.1. TCP/IP</h3></div></div></div><div class="section" title="UBF: Universal Binary Format"><div class="titlepage"><div><div><h4 class="title"><a id="_ubf_universal_binary_format"></a>UBF: Universal Binary Format</h4></div></div></div><p>The name "UBF" is short for "Universal Binary Format".  UBF is
commonly used to refer to the network transport based on UBF(a) and to
the overall UBF framework.</p><p>See <a class="xref" href="#UBFa" title="3.1. UBF(a)">Section 3.1, “UBF(a)”</a> for further information.</p></div><div class="section" title="EBF: Erlang Binary Format"><div class="titlepage"><div><div><h4 class="title"><a id="_ebf_erlang_binary_format"></a>EBF: Erlang Binary Format</h4></div></div></div><p>EBF is an implementation of UBF(b) but it does not use UBF(a) for the
client and server communication.  Instead, Erlang-style conventions
are used instead:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Structured terms are serialized via the Erlang BIFs term_to_binary()
  and binary_to_term().
</li><li class="listitem"><p class="simpara">
Terms are framed using the <span class="emphasis"><em>gen_tcp</em></span> {packet, 4} format: a 32-bit
  unsigned integer (big-endian?) specifies packet length.
</p><pre class="screen">+-------------------------+-------------------------------+
| Packet length (32 bits) | Packet data (variable length) |
+-------------------------+-------------------------------+</pre></li></ul></div><p>The name "EBF" is short for "Erlang Binary Format".</p></div><div class="section" title="JSF: JavaScript Format"><div class="titlepage"><div><div><h4 class="title"><a id="_jsf_javascript_format"></a>JSF: JavaScript Format</h4></div></div></div><p>JSF is an implementation of UBF(b) but it does not use UBF(a) for the
client and server communication.  Instead, JSON <a class="xref" href="#RFC4627">[RFC4627]</a> is used
instead as the wire format.  The name "JSF" is short for "JavaScript
Format".</p><p>There is no generally agreed upon convention for converting Erlang
terms to JSON objects.  JSF uses the convention set forth by
MochiWeb’s JSON library <a class="xref" href="#MOCHIJSON2">[MOCHIJSON2]</a>.  In addition, there are a
couple of other conventions layered on top of MochiWeb’s
implementation.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The UBF(b) contract checker has been modified to make a distinction
  between an Erlang record and an arbitrary Erlang tuple.  An
  experienced Erlang developer would view such a distinction either
  with skepticism or with approval.
</li><li class="listitem">
For the skeptics, the contract author has the option of having the
  UBF(b) contract compiler automatically generate Erlang -record()
  definitions for appropriate tuples within the contract.  Such record
  definitions are very convenient for developers on the Erlang side of
  the world, but they introduce more complication to the JavaScript
  side of the world.  For example, JavaScript does not have a concept
  of an arbitrary atom, as Erlang does.  Also, the JavaScript side
  must make a distinction between {foo, 42} and {bar, 42} when #foo is
  a record on the Erlang side but #bar is not.
</li></ul></div><p>This extra convention creates something slightly messy-looking, if you
look at the raw JSON passed back-and-forth.  The examples of the
Erlang record {foo, 42} and the general tuple {bar, 42} would look
like this:</p><pre class="screen">   record (defined in the contract as "foo() = #foo{attribute1 = term()};")

      {"$R":"foo", "attribute1":42}

   general tuple

      {"$T":[{"$A":"bar"}, 42]}</pre><p>However, it requires very little JavaScript code to convert objects
with the "$R", "$T", and "$A" notation (for records, tuples, and
atoms) into whatever object is most convenient.</p><p>See <a class="xref" href="#UBF_JSONRPC">[UBF_JSONRPC]</a> for further information.</p><div class="tip" title="Tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Gemini Mobile Technologies, Inc. has implemented and open-sourced
a module for classifying the input character set to detect non-UTF8
JSON inputs <a class="xref" href="#JSFCHARSET">[JSFCHARSET]</a>.</p></td></tr></table></div></div><div class="section" title="TBF / FTBF / NTBF / FNTBF: Binary Format - Thrift / Framed Thrift / Native Thrift / Framed Native Thrift"><div class="titlepage"><div><div><h4 class="title"><a id="_tbf_ftbf_ntbf_fntbf_binary_format_thrift_framed_thrift_native_thrift_framed_native_thrift"></a>TBF / FTBF / NTBF / FNTBF:  Binary Format - Thrift / Framed Thrift / Native Thrift / Framed Native Thrift</h4></div></div></div><p>TBF and NTBF is an implementation of UBF(b) but it does not use UBF(a)
for the client and server communication.  Instead, Thrift <a class="xref" href="#THRIFT">[THRIFT]</a>
is used instead as the wire format.  The name "TBF" is short for
"Thrift Binary Format".  The name "NTBF" is short for "Native Thrift
Binary Format".  FTBF and FNTBF are framed versions of TBF and NTBF,
respectively.</p><p>TBF follows the conventions set forth by the Thrift community by
re-using Thrift’s binary wire-protocol except for the following
exceptions:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The name of Thrift messages are hard-coded to the Thrift name
  "$UBF".
</li><li class="listitem">
The name of Thrift structs are not removed before being written to
  the network.
</li><li class="listitem">
TBF does not use nor require a Thrift IDL.
</li><li class="listitem">
TBF by convention requires the client to read a "server hello"
  message at the start of establishing a new TCP/IP connection.
</li></ul></div><p>TBF <span class="strong"><strong>can</strong></span> encode and decode all UBF(b) objects.  Synchronous calls are
implemented as Thrift <span class="emphasis"><em>T-CALL</em></span> and <span class="emphasis"><em>T-REPLY</em></span> message pairs.
Asynchronous casts are implemented as Thrift <span class="emphasis"><em>T-ONEWAY</em></span> messages.</p><div class="caution" title="Caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>TBF is not compatible with standard Thrift clients and
servers.</p></td></tr></table></div><p>NTBF follows all of the conventions set forth by the Thrift community
by re-using Thrift’s binary wire-protocol.  A standard Thrift client
can communicate with a UBF "NTBF" server and a UBF "NTBF" client can
communicate with a standard Thrift server.</p><p>NTBF <span class="strong"><strong>cannot</strong></span> encode and decode all UBF(b) objects.  There is no
straigthforward convention for converting Erlang terms to Thrift
messages.  Synchronous calls are implemented as Thrift <span class="emphasis"><em>T-CALL</em></span> and
<span class="emphasis"><em>T-REPLY</em></span> message pairs or <span class="emphasis"><em>T-CALL</em></span> and <span class="emphasis"><em>T-EXCEPTION</em></span> message pairs.
Asynchronous casts are implemented as Thrift <span class="emphasis"><em>T-ONEWAY</em></span> messages.</p><p>The NTBF transport is under active development to enhance, to improve,
to simplify the integration of Thrift to the UBF framework.  The
impedance mismatch between the two approaches of Thrift and UBF can
only be addressed by further development.</p><div class="caution" title="Caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Currently, NTBF only implements the encoding and decoding of
Thrift’s binary wire-protocol.  Unlike standard Thrift clients and
servers, a NTBF client and server must "manually" implement the
features provided by the Thrift IDL.</p></td></tr></table></div><p>See <a class="xref" href="#UBF_THRIFT">[UBF_THRIFT]</a> for further information.</p></div><div class="section" title="Miscellaneous"><div class="titlepage"><div><div><h4 class="title"><a id="_miscellaneous_2"></a>Miscellaneous</h4></div></div></div><p>It is worthwhile to mention two new TCP/IP transports namely PBF and
ABF under investigation.  The name "PBF" is short for "Google’s
Protocol Buffers Format" <a class="xref" href="#PROTOBUF">[PROTOBUF]</a>.  The name "ABF" is short for
"Avro Binary Format" <a class="xref" href="#AVRO">[AVRO]</a>.</p></div></div><div class="section" title="5.2. HTTP"><div class="titlepage"><div><div><h3 class="title"><a id="_http"></a>5.2. HTTP</h3></div></div></div><div class="section" title="JSON-RPC"><div class="titlepage"><div><div><h4 class="title"><a id="_json_rpc"></a>JSON-RPC</h4></div></div></div><p>JSON-RPC <a class="xref" href="#JSONRPC">[JSONRPC]</a> is a lightweight remote procedure call protocol
similar to XML-RPC.  The UBF framework implementation of JSON-RPC
brings together JSF’s encoder/decoder, UBF(b)'s contract checking, and
an HTTP transport.</p><div class="figure"><a id="idp10097216"></a><p class="title"><strong>Figure 2. Programming By Contract w/ Multiple Transports</strong></p><div class="figure-contents"><a class="ulink" href="images/ubf-flow-02.svg" target="_top">
  <div class="mediaobject"><img src="images/ubf-flow-02.png" alt="Programming By Contract w/ Multiple Transports" /></div>
</a></div></div><br class="figure-break" /><p>As previously stated, central to UBF is the idea of a "Contract" which
regulates the set of legal conversations that can take place between a
client and a server.  The client-side is depicted in "red" and the
server-side is depicted in "blue".  The client and server communicate
with each other via a TCP/IP and/or HTTP.</p><p>Central to UBF is the idea of contract(s) can be shared and re-used by
multiple transports.  Any data that violates the <span class="emphasis"><em>same</em></span> contract(s) is
rejected regardless of the transport.</p><p>See <a class="xref" href="#UBF_JSONRPC">[UBF_JSONRPC]</a> for further information.</p></div></div><div class="section" title="5.3. Miscellaneous"><div class="titlepage"><div><div><h3 class="title"><a id="_miscellaneous_3"></a>5.3. Miscellaneous</h3></div></div></div><p>Several transports that do not require an explicit network socket have
been added to the UBF framework.  These transports permit an
application to call a plugin directly without the need for TCP/IP or
HTTP.</p><div class="section" title="ETF: Erlang Term Format"><div class="titlepage"><div><div><h4 class="title"><a id="_etf_erlang_term_format"></a>ETF: Erlang Term Format</h4></div></div></div><p>The concept "ETF" was added to the UBF framework.  This transport
relies on Erlang’s Native Distribution for synchronous calls and
asynchronous casts.</p><p>The name "ETF" is short for "Erlang Term Format".</p></div><div class="section" title="LPC: Local Procedure Call"><div class="titlepage"><div><div><h4 class="title"><a id="_lpc_local_procedure_call"></a>LPC: Local Procedure Call</h4></div></div></div><p>The concept "LPC" was added to the UBF framework.  This transport is a
"non-transport" that invokes synchronous calls directly to a plugin.
Support for asynchronous casts has not been added (or designed) yet.</p><p>The name "LPC" is short for "Local Procedure Call".</p><div class="note" title="Note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>LPC is used to implement the JSON-RPC transport.</p></td></tr></table></div><p></p></div></div></div><div class="section" title="6. Servers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Servers"></a>6. Servers</h2></div></div></div><p>The UBF framework provides two types of Erlang servers: "stateless"
and "stateful".  The stateless server is an extension of Joe
Armstrong’s original UBF server implementation.  The "stateful" server
is Joe Armstrong’s original UBF server implementation.</p><p>UBF servers are introspective - which means the servers can describe
themselves.  The following commands (described in UBF(a) format) are
always available:</p><div class="variablelist"><dl><dt><span class="term">
'help' $
</span></dt><dd>
  Help information
</dd><dt><span class="term">
'info' $
</span></dt><dd>
  Short information about the current service
</dd><dt><span class="term">
'description' $
</span></dt><dd>
  Long information about the current service
</dd><dt><span class="term">
'services' $
</span></dt><dd>
  A list of available services
</dd><dt><span class="term">
'contract' $
</span></dt><dd>
  Return the service contract
</dd><dt><span class="term">
{'startSession', "Name", Args} $
</span></dt><dd>
  To start a new session for the Name service.  Args are initial
  arguments for the Name service and is specific to that service.
</dd><dt><span class="term">
{'restartService', "Name", Args} $
</span></dt><dd>
  To restart the Name service.  Args are restart arguments for the
  Name service and is specific to that service.
</dd></dl></div><p>The "ubf_server" Erlang module implements most of the commonly-used
server-side functions and provides several ways to start a server.
Configuration options for both types of servers are the same.
However, the plugin callback API is different.</p><pre class="screen">-module(ubf_server).

-type name() :: atom().
-type plugins() :: [module()].
-type ipport() :: pos_integer().
-type options() :: [{atom(), term()}].

-spec start(plugins(), ipport()) -&gt; true.
-spec start(name(), plugins(), ipport()) -&gt; true.
-spec start(name(), plugins(), ipport(), options()) -&gt; true.

-spec start_link(plugins(), ipport()) -&gt; true.
-spec start_link(name(), plugins(), ipport()) -&gt; true.
-spec start_link(name(), plugins(), ipport(), options()) -&gt; true.</pre><p>The start/{2,3,4} and start_link/{2,3,4} functions start a registered
server and a TCP listener on ipport() and register all of the protocol
implementation modules in the plugins() list.  If name() is undefined,
the server is not registered.  The list of supported options() are as
follows:</p><div class="variablelist"><dl><dt><span class="term">
{'idletimer', non_neg_integer() | 'infinity'}
</span></dt><dd>
  Maximum time (in milliseconds) that a client connection may remain
  idle before the server will close the connection.  Default:
  'infinity'
</dd><dt><span class="term">
{'maxconn', non_neg_integer()}
</span></dt><dd>
  Maximum number of simultaneous TCP connections allowed.  Default:
  10000.
</dd><dt><span class="term">
{'proto', {'ubf' | 'ebf' | 'jsf' | 'tbf' |  'ftbf' | atom()}}
</span></dt><dd>
  Enable the UBF, EBF, JSF, TBF, FTBF, or an alternative protocol wire
  format. Default: 'ubf'.
</dd><dt><span class="term">
{'proto', {'ubf' | 'ebf' | 'jsf' | 'tbf' |  'ftbf' | atom(), proplist()}}
</span></dt><dd><p class="simpara">
  Enable the UBF, EBF, JSF, TBF, FTBF, or an alternative protocol wire
  format with options. Default: {'ubf', []}. Supported options:
</p><div class="variablelist"><dl><dt><span class="term">
'safe'
</span></dt><dd>
    Prevents decoding data that may be used to attack the Erlang
    system.  In the event of receiving unsafe data, decoding fails
    with a badarg error.
</dd></dl></div></dd><dt><span class="term">
{'registeredname', name()}
</span></dt><dd>
  Set the name to be registered for the TCP listener.  If
  'undefined', a default name is automatically registered.  Default:
  'undefined'.
</dd><dt><span class="term">
{'statelessrpc', boolean()}
</span></dt><dd>
  Run the stateless variety of a UBF(b) contract.  A stateless
  contract is an extension of Joe Armstrong’s original UBF server
  implementation.  Default: 'false'.
</dd><dt><span class="term">
{'startplugin', module()}
</span></dt><dd>
  Set the starting plugin, set after a client first connects to the
  server.  If not set, client may select the service using the
  startSession() API.  There is no default setting.
</dd><dt><span class="term">
{'serverhello', string() | 'undefined'}
</span></dt><dd>
  Meta contract greeting string, sent when a client first connects to
  the server.  If 'undefined', server hello is not sent to the
  client.  Default: "meta_server".
</dd><dt><span class="term">
{'simplerpc', boolean()}
</span></dt><dd>
  Set the simple RPC mode.  If 'true', server returns only the rpc
  reply to client.  If 'false', server returns the rpc reply and next
  state to client.  Default: 'false'.
</dd><dt><span class="term">
{'verboserpc', boolean()}
</span></dt><dd>
  Set the verbose RPC mode.  If 'true', server calls the plugin
  handler with the rpc request and matched contract types.  If
  'false', server calls the plugin handler only with the rpc request.
  Default: 'false'.
</dd><dt><span class="term">
{'tlog_module', module() | {module(), boolean()}}
</span></dt><dd>
  Set the transaction log callback module and optionally control the
  built-in calls by 'contract_manager_tlog' to the 'error_logger'
  module.  If the 2-tuple representation is used and the boolean()
  member is 'false', then calls to 'error_logger' will not be
  attempted.  Default: 'undefined'.  See <a class="xref" href="#TLOG" title="Transaction Logging">the section called “Transaction Logging”</a> for further
  information.
</dd><dt><span class="term">
{'process_options', list()}
</span></dt><dd>
  Specify additional options used for spawning server and/or client
  related erlang processes.  Typically used to specify non-default,
  garbage collection options.  Default: [].
</dd></dl></div><p>The "ubf_server" Erlang module doesn’t provide a "stop" function.  To
stop the server, instead stop the TCP listener that controls it.  See
the "proc_socket_server" Erlang module for extra details.</p><div class="note" title="Note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The NTBF and FNTBF transport protocol is indirectly enabled by
specifying the following options: [{'proto', 'tbf'},
{'serverhello', 'undefined'}, {'simplerpc', 'true'}] or
[{'proto', 'ftbf'}, {'serverhello', 'undefined'}, {'simplerpc',
'true'}].</p></td></tr></table></div><div class="section" title="6.1. Stateless"><div class="titlepage"><div><div><h3 class="title"><a id="_stateless"></a>6.1. Stateless</h3></div></div></div><p>The stateless server provides a simplified callback API and
implementation in comparision to Joe Armstrong’s original UBF server.
The stateless server is helpful to applications that do not require
explicit state management by the UBF server.</p><p>The "ubf_plugin_stateless.hrl" Erlang header file defines the callback
APIs to be implemented by a stateless plugin.  The five callbacks are
mandatory for all stateless plugins.</p><pre class="screen">%% common callback API
-spec ubf_info() -&gt; string().
-spec ubf_description() -&gt; string().
-spec handlerStop(Handler::pid(), Reason::term(), StateData::term()) -&gt;
                  NewStateData::term().

%% stateless callback API
-spec handlerStart(Args::term()) -&gt;
                  {accept, Reply::term(), StateName::atom(), StateDate::term()} |
                  {reject, Reply::term()}.
-spec handlerRpc(Call::term()) -&gt; Reply::term().</pre><p>The ubf_info/0 and ubf_description/0 functions provide short and long
information about the plugin’s service, respectively.</p><p>The handlerStart/1 function is called when starting a new session for
the plugin’s service.  The plugin may accept or reject the start
session request.  When accepted, the plugin returns the reply for the
client, the name of the state to be used for the entire session, and
optional data for the state.  When rejected, the plugin returns the
error for the client.</p><p>The handlerStop/3 function is called when stopping a session of the
plugin’s service.  The plugin may perform some cleanup inside the
handlerStop function.</p><p>The handlerRpc/1 function is called when processing a synchronous call.</p><p>For example, the following "skeleton" implementation of a <a class="xref" href="#BERTRPC">[BERTRPC]</a>
server implemented by UBF illustrates a typical stateless server.  The
source code for this implementation can be found on github
<a class="xref" href="#UBF_BERTRPC">[UBF_BERTRPC]</a>.</p><pre class="programlisting">%%% -*- mode: erlang -*-
%%% @doc Sample BERT-RPC plugin.
%%%
%%%

-module(ubf_bertrpc_plugin).
-behaviour(ubf_plugin_stateless).

%% Required (except keepalive/0) callback API for UBF stateless
%% implementations.
-export([info/0, description/0, keepalive/0]).
-export([handlerStart/1, handlerStop/3, handlerRpc/1, handlerEvent/1]).

-import(ubf_plugin_handler, [sendEvent/2, install_handler/2]).

-compile({parse_transform,contract_parser}).
-add_contract("ubf_bertrpc_plugin").

-include("ubf.hrl").
-include("ubf_plugin_stateless.hrl").

info() -&gt;
    "I am a BERT-RPC server".

description() -&gt;
    "A BERT-RPC server programmed by UBF".

keepalive() -&gt;
    ok.

%% @doc start handler
handlerStart(_Args) -&gt;
    ack = install_handler(self(), fun handlerEvent/1),
    {accept,ok,none,unused}.

%% @doc stop handler
handlerStop(_Pid, _Reason, _StateData) -&gt;
    unused.

%% @doc rpc handler
%% @TODO Implement BERT-RPC 1.0 synchronous events
handlerRpc(Event) when Event==info; Event==description -&gt;
    ?S(?MODULE:Event());
handlerRpc(Event) when Event==keepalive -&gt;
    ?MODULE:Event().

%% @doc event handler
%% @TODO: Implement BERT-RPC 1.0 asynchronous events
handlerEvent(Event) -&gt;
    %% Let's fake it and echo the request
    sendEvent(self(), Event),
    fun handlerEvent/1.</pre><p>The above example also introduces three new concepts:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The install_handler/2 and handleEvent/1 functions illustrate how to
  receive asynchronous casts sent from the client to the server.  The
  handler fun Fun should be a function of arity 1.  When an
  asynchronous UBF message is received, the callback function is
  called with the event as its single argument.  The Fun is called by
  the ubf plugin handler process so the Fun can crash and/or block
  this process.  The Fun should also return the same or a new Fun for
  the next asynchronous event.  If the Fun must maintain its own
  state, then an intermediate anonymous fun must be used to to bind
  the state.
</li><li class="listitem">
The sendEvent/2 function illustrates how to send asynchronous casts
  from the server to the client.
</li><li class="listitem">
The "?S(X)" macro definition plus other helpers are located in the
  "ubf.hrl" Erlang header file.  For Erlang, the implementation of a
  UBF string is a two tuple having '#S' as the first element and a
  list of integers as the second element.  A similar technique is also
  used for the implementation of a UBF proplist (i.e. '#P' and
  "?P(X)).
</li></ul></div></div><div class="section" title="6.2. Stateful"><div class="titlepage"><div><div><h3 class="title"><a id="_stateful"></a>6.2. Stateful</h3></div></div></div><p>The stateful server is Joe Armstrong’s original UBF server.  The
stateful server permits a plugin to transition from one state to
another and also supports a manager framework for managing application
state between multiple clients.</p><p>The "ubf_plugin_stateless.hrl" Erlang header file defines the callback
APIs to be implemented by a stateful plugin.  The eight callbacks are
mandatory for all stateful plugins.</p><pre class="screen">%% common callback API
-spec ubf_info() -&gt; string().
-spec ubf_description() -&gt; string().
-spec handlerStop(Handler::pid(), Reason::term(), ManagerData::term()) -&gt;
                  NewManagerData::term().

%% stateful callback API
-spec handlerStart(Args::term(), Manager::pid()) -&gt;
                  {accept, Reply::term(), StateName::atom(), StateDate::term()} |
                  {reject, Reply::term()}.
-spec handlerRpc(StateName::atom(), Call::term(), StateDate::term(), Manager::pid()) -&gt;
                {Reply::term(), NewStateName::atom(), NewStateData::term()}.

-spec managerStart(Args::term()) -&gt;
                   {ok, ManagerData::term()}.
-spec managerRestart(Args::term(), Manager::pid()) -&gt;
                     ok | {error, Reason::term()}.
-spec managerRpc(Args::term(), ManagerData::term()) -&gt;
                 {ok, NewManagerData::term()} | {error, Reason::term()}.</pre><p>The ubf_info/0 and ubf_description/0 functions provide short and long
information about the plugin’s service, respectively.</p><p>The handlerStart/2 function is called when starting a new session for
the plugin’s service.  The plugin may accept or reject the start
session request.  When accepted, the plugin returns the reply for the
client, the name of the initial state to be used for the session, and
optional data for the state.  When rejected, the plugin returns the
error for the client.</p><p>The handlerStop/3 function is called when stopping a session of the
plugin’s service.  The plugin may perform some cleanup inside the
handlerStop function.</p><p>The handlerRpc/1 function is called when processing a synchronous
call.</p><p>The managerStart/1 function is called once at the start of the
server’s initialization for each plugin’s service.</p><p>The managerRestart/2 function is called to restart a plugin’s service.</p><p>The managerRpc/2 function is called when processing a call from
handler.  A handler uses the ubf_plugin_handler:ask_manager/2 function
API to make a synchronous call to the manager.</p><p>For an example stateful server plugin, please see the
"test/unit/irc_plugin.erl" Erlang module in the <a class="xref" href="#UBF">[UBF]</a>
repository.  This plugin is the actual server-side implementation for
the IRC protocol application described earlier.</p><p></p></div></div><div class="section" title="7. Clients"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_clients"></a>7. Clients</h2></div></div></div><div class="section" title="7.1. Erlang"><div class="titlepage"><div><div><h3 class="title"><a id="_erlang"></a>7.1. Erlang</h3></div></div></div><p>The UBF framework provides two types of Erlang clients: "rpc" and
"lpc".  The rpc client is the default client that supports
TCP/IP-based and ETF transports.  The lpc client is an alternative
client for making a synchronous local procedure call to a plugin’s
implementation.</p><p>The "ubf_client" Erlang module implements most of the commonly-used
client-side functions and contains the implementation for the two
types of Erlang clients.</p><pre class="screen">-module(ubf_client).

-type host() :: nonempty_string().
-type ipport() :: pos_integer().
-type name() :: atom().
-type server() :: name() | pid().
-type plugin() :: module().
-type plugins() :: [plugin()].
-type options() :: [{atom(), term()}].
-type service() :: {'#S', nonempty_string()} | undefined.
-type statename() :: atom().
-type tlogger() :: module().

-spec connect(host() | plugins(), ipport() | server()) -&gt;
              {ok, Client::pid(), service()} | {error, term()}.
-spec connect(host() | plugins(), ipport() | server(), timeout()) -&gt;
              {ok, Client::pid(), service()} | {error, term()}.
-spec connect(host() | plugins(), ipport() | server(), options(), timeout()) -&gt;
              {ok, Client::pid(), service()} | {error, term()}.

-spec rpc(Client::pid(), Call::term()) -&gt; timeout | term() | no_return().
-spec rpc(Client::pid(), Call::term(), timeout()) -&gt; timeout | term() | no_return().

-spec stop(Client::pid()) -&gt; ok.

-spec sendEvent(Handler::pid(), Cast::term()) -&gt; ok | no_return().

-spec install_default_handler(Client::pid()) -&gt; ack.
-spec install_handler(Client::pid(), Fun::fun()) -&gt; ack.

-spec lpc(plugin(), Call::term()) -&gt; term().
-spec lpc(plugin(), Call::term(), statename()) -&gt; term().
-spec lpc(plugin(), Call::term(), statename(), tlogger()) -&gt; term().</pre><p>The connect/{2,3,4} functions connect to a UBF server.  Upon success,
the UBF client’s pid() and the name of the UBF server’s service (if
known) is returned.  For TCP/IP transports, the default method is to
connect to the specified host() and TCP ipport().  For the ETF
transport, the alternative method is to connect to server() using the
specified plugins().  The server() is either the process id or process
registered name for an already-started UBF server.  See <a class="xref" href="#Servers" title="6. Servers">Section 6, “Servers”</a>
for a description of options().</p><p>The rpc/{2,3} functions make a synchronous call to the server.</p><p>The stop/1 function closes the connection with the server and stops
the client.</p><p>The sendEvent/2, install_default_handler/1, and install_handler/2
functions behave in the same way as the server-side implementation to
send and receive asynchronous casts.</p><p>The lpc/{2,3,4} functions make a synchronous local procedure call to a
plugin’s implementation.  Regarding the tlogger(), see <a class="xref" href="#TLOG" title="Transaction Logging">the section called “Transaction Logging”</a> for
further information.</p></div><div class="section" title="7.2. Python"><div class="titlepage"><div><div><h3 class="title"><a id="_python"></a>7.2. Python</h3></div></div></div><div class="section" title="EBF"><div class="titlepage"><div><div><h4 class="title"><a id="_ebf"></a>EBF</h4></div></div></div><p><span class="emphasis"><em>Under Construction - To Be Added</em></span></p></div><div class="section" title="JSON-RPC"><div class="titlepage"><div><div><h4 class="title"><a id="_json_rpc_2"></a>JSON-RPC</h4></div></div></div><p><span class="emphasis"><em>Under Construction - To Be Added</em></span></p></div></div><div class="section" title="7.3. Java"><div class="titlepage"><div><div><h3 class="title"><a id="_java"></a>7.3. Java</h3></div></div></div><div class="section" title="UBF"><div class="titlepage"><div><div><h4 class="title"><a id="_ubf"></a>UBF</h4></div></div></div><p><span class="emphasis"><em>Under Construction - To Be Added</em></span></p><p></p></div></div></div><div class="section" title="8. Miscellaneous"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_miscellaneous_4"></a>8. Miscellaneous</h2></div></div></div><div class="section" title="8.1. Testing"><div class="titlepage"><div><div><h3 class="title"><a id="_testing"></a>8.1. Testing</h3></div></div></div><div class="section" title="Unit Tests"><div class="titlepage"><div><div><h4 class="title"><a id="_unit_tests"></a>Unit Tests</h4></div></div></div><p>The unit tests in the "test/unit" directory provide small examples of
how to use all of the public API.  In particular, the *client*.erl
files contain comments at the top with a list of prerequisites and
small examples, recipe-style, for starting each server and using the
client.</p></div><div class="section" title="EUnit Tests"><div class="titlepage"><div><div><h4 class="title"><a id="_eunit_tests"></a>EUnit Tests</h4></div></div></div><p>The eunit tests in the "test/eunit" directory perform several smoke
and error handling uses cases.</p></div><div class="section" title="QuickCheck Tests"><div class="titlepage"><div><div><h4 class="title"><a id="_quickcheck_tests"></a>QuickCheck Tests</h4></div></div></div><p>The quickcheck tests and related helper libaries in the "test/eqc"
directory have not been open sourced yet.  Please stay tuned!</p><p>See <a class="xref" href="#QUVIQ">[QUVIQ]</a> for further information about quickcheck.</p></div></div><div class="section" title="8.2. Utilities"><div class="titlepage"><div><div><h3 class="title"><a id="_utilities"></a>8.2. Utilities</h3></div></div></div><div class="section" title="Transaction Logging"><div class="titlepage"><div><div><h4 class="title"><a id="TLOG"></a>Transaction Logging</h4></div></div></div><p>For Erlang, the UBF server and the UBF "LPC" client can be configured
to generate a transaction log.  The transaction log module must
implement the following tlog/6 callback API.</p><pre class="screen">-type op() :: rpc | lpc | event_in | event_out.
-type now() :: {pos_integer(), pos_integer(), pos_integer()}.
-type plugin() :: module().

-spec tlog(op(), Start::now(), plugin(), Q::term(), Reply::term(), Status::term()) -&gt; ok.</pre></div><div class="section" title="Canonical Contracts"><div class="titlepage"><div><div><h4 class="title"><a id="_canonical_contracts"></a>Canonical Contracts</h4></div></div></div><p>For documentation purposes, it is helpful to generate a "canonical"
version of a UBF contract.  This feature is especially helpful when
importing UBF(b) types from one or more plugins.</p><p>For UBF, the ubf_utils:ubf_contract/{1,2} functions are available for
this purpose.  For JSON-RPC (and JSF indirectly), the
jsf_utils:ubf_contract/{1,2} functions are available for this purpose.</p><p></p></div></div></div><div class="section" title="9. Building UBF from Source - Option 1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_building_ubf_from_source_option_1"></a>9. Building UBF from Source - Option 1</h2></div></div></div><p>To download, build, and test the UBF application in one shot, please
follow this recipe:</p><pre class="screen">$ mkdir working-directory-name
$ cd working-directory-name
$ git clone https://github.com/ubf/ubf.git ubf
$ cd ubf
$ ./rebar get-deps
$ ./rebar compile
$ ./rebar eunit</pre><p>For an alternative recipe with other "features" albeit more complex,
please read further.</p></div><div class="section" title="10. Building UBF from Source - Option 2"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_building_ubf_from_source_option_2"></a>10. Building UBF from Source - Option 2</h2></div></div></div><p>This section describes the basic recipes for the following items:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
UBF Downloading
</li><li class="listitem">
UBF Building, Testing, and Dialyzing
</li><li class="listitem">
UBF Documentation
</li><li class="listitem">
Erlang/OTP System
</li><li class="listitem">
GitHub - Forking Your Own Repositories
</li></ul></div><p>Before getting started, review this checklist of tools and software.
Please install and setup as needed.</p><div class="variablelist"><dl><dt><span class="term">
Git (Mandatory)
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
Git - <a class="ulink" href="http://git-scm.com/" target="_top">http://git-scm.com/</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<span class="strong"><strong>Git 1.5.4 or newer, Git 1.7.9.3 has been tested recently</strong></span>
</li><li class="listitem">
<span class="emphasis"><em>required for Repo and GitHub</em></span>
</li></ul></div></li><li class="listitem"><p class="simpara">
GitHub - <a class="ulink" href="https://github.com" target="_top">https://github.com</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Anonymous read-only access using the GIT protocol is default.
</li><li class="listitem">
Team members having read-write access should add his/her ssh
    public key under your GitHub account.
</li></ul></div></li></ul></div></dd><dt><span class="term">
Erlang/OTP (Mandatory)
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
Erlang - <a class="ulink" href="http://www.erlang.org/" target="_top">http://www.erlang.org/</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<span class="strong"><strong>R13B04 or newer, R15B has been tested most recently</strong></span>
</li><li class="listitem">
If needed, see <a class="xref" href="#ErlangOTP" title="10.5. Erlang/OTP System">Section 10.5, “Erlang/OTP System”</a> for instructions to build Erlang/OTP
    from source.
</li></ul></div></li></ul></div></dd><dt><span class="term">
Python (Mandatory)
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
Python - <a class="ulink" href="http://www.python.org" target="_top">http://www.python.org</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
<span class="strong"><strong>Python 2.4 or newer, Python 2.7.1 has been tested most recently
     (CAUTION: Python 3.x might be too new)</strong></span>
</li><li class="listitem">
<span class="emphasis"><em>required for Repo and AsciiDoc</em></span>
</li></ul></div></li></ul></div></dd><dt><span class="term">
AsciiDoc (Optional)
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
AsciiDoc - <a class="ulink" href="http://www.methods.co.nz/asciidoc/index.html" target="_top">http://www.methods.co.nz/asciidoc/index.html</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
Must be version 8.6.1 or newer
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
8.6.6 is the version most recently tested for UBF
</li></ul></div></li><li class="listitem"><p class="simpara">
Plus the following support tools:
</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
ImageMagick - <a class="ulink" href="http://www.imagemagick.org/" target="_top">http://www.imagemagick.org/</a>
</li><li class="listitem">
Graphviz - <a class="ulink" href="http://www.graphviz.org/" target="_top">http://www.graphviz.org/</a>
</li><li class="listitem">
Mscgen - <a class="ulink" href="http://www.mcternan.me.uk/mscgen/" target="_top">http://www.mcternan.me.uk/mscgen/</a>
</li><li class="listitem">
Dia - <a class="ulink" href="http://projects.gnome.org/dia/" target="_top">http://projects.gnome.org/dia/</a>
</li></ul></div></li></ul></div></li><li class="listitem"><p class="simpara">
dblatex - <a class="ulink" href="http://dblatex.sourceforge.net/" target="_top">http://dblatex.sourceforge.net/</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Optional for building a PDF version of UBF’s documentation.
</li></ul></div></li><li class="listitem"><p class="simpara">
w3m - <a class="ulink" href="http://w3m.sourceforge.net/" target="_top">http://w3m.sourceforge.net/</a>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Optional for building a text version of UBF’s documentation.
</li></ul></div></li></ul></div></dd></dl></div><p>In addition to the above list, UBF also depends on two tools to
automate the downloading and the packaging steps.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Repo - <a class="ulink" href="http://source.android.com/source/git-repo.html" target="_top">http://source.android.com/source/git-repo.html</a>
</li><li class="listitem">
Rebar - <a class="ulink" href="https://github.com/basho/rebar/wiki" target="_top">https://github.com/basho/rebar/wiki</a>
</li></ul></div><p>Instructions for downloading the Repo tool are described next.  The
Rebar tool is included in UBF’s git repositories so there is no need
to download it separately.  Please refer to the above sites for
further information regarding the usage of these tools.</p><div class="section" title="10.1. Download"><div class="titlepage"><div><div><h3 class="title"><a id="DOWNLOAD"></a>10.1. Download</h3></div></div></div><p>The first step is to download the Git repositories from GitHub.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
Configure your e-mail and name for Git
</p><pre class="screen">$ git config --global user.email "you@example.com"
$ git config --global user.name "Your Name"</pre></li><li class="listitem"><p class="simpara">
Install Repo
</p><pre class="screen">$ mkdir -p ~/bin
$ wget -O - https://dl-ssl.google.com/dl/googlesource/git-repo/repo &gt; ~/bin/repo
$ chmod a+x ~/bin/repo</pre></li><li class="listitem"><p class="simpara">
Create working directory
</p><pre class="screen">$ mkdir working-directory-name
$ cd working-directory-name
$ repo init -u https://github.com/ubf/manifests.git -m ubf-default.xml</pre><div class="note" title="Note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Your "Git" identity is needed during the init step.  Please
enter the name and email of your GitHub account if you have one.  Team
members having read-write access are recommended to use "repo init -u
<a class="ulink" href="mailto:git@github.com" target="_top">git@github.com</a>:ubf/manifests.git -m ubf-default-rw.xml".</p></td></tr></table></div><div class="tip" title="Tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>If you want to checkout the latest development version of UBF,
please append " -b dev" to the repo init command.</p></td></tr></table></div></li><li class="listitem"><p class="simpara">
Download Git repositories
</p><pre class="screen">$ cd working-directory-name
$ repo sync</pre></li></ol></div></div><div class="section" title="10.2. Build - Mandatory"><div class="titlepage"><div><div><h3 class="title"><a id="BUILD"></a>10.2. Build - Mandatory</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
Build UBF
</p><pre class="screen">$ cd working-directory-name
$ make compile</pre><div class="tip" title="Tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>If the response is "make: erl: Command not found", please make
sure Erlang/OTP is installed and "otp-installing-directory-name/bin"
is added to your $PATH environment.</p></td></tr></table></div></li><li class="listitem"><p class="simpara">
Run the unit tests
</p><pre class="screen">$ cd working-directory-name
$ make eunit</pre></li></ol></div></div><div class="section" title="10.3. Build - Optional"><div class="titlepage"><div><div><h3 class="title"><a id="_build_optional"></a>10.3. Build - Optional</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
Dialyzer Testing <span class="emphasis"><em>basic recipe</em></span>
</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
Build Dialyzer’s PLT <span class="emphasis"><em>(required once)</em></span>
</p><pre class="screen">$ cd working-directory-name
$ make build-plt</pre><div class="tip" title="Tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Check Makefile and dialyzer’s documentation for further
information.</p></td></tr></table></div></li><li class="listitem"><p class="simpara">
Dialyze with specs
</p><pre class="screen">$ cd working-directory-name
$ make dialyze</pre><div class="caution" title="Caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>If you manually run dialyzer with the "-r" option, execute
"make clean compile" first to avoid finding duplicate beam files
underneath rebar’s .test directory.  Check Makefile for further
information.</p></td></tr></table></div></li><li class="listitem"><p class="simpara">
Dialyze without specs
</p><pre class="screen">$ cd working-directory-name
$ make dialyze-nospec</pre></li></ol></div></li><li class="listitem"><p class="simpara">
To build the Java client and run its encoding/decoding unit test:
</p><pre class="screen">$ cd working-directory-name
$ make -C lib/ubf/priv/java</pre></li><li class="listitem"><p class="simpara">
The Python client depends on the "Py-Interface" library.  To clone
  and build it, use:
</p><pre class="screen">$ cd working-directory-name
$ git clone git://repo.or.cz/py_interface.git
$ cd py_interface
$ autoconf
$ make</pre><div class="tip" title="Tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Then install as a normal Python package or run using "env
PYTHONPATH=working-directory-name/py_interface python your-script.py"</p></td></tr></table></div></li></ol></div></div><div class="section" title="10.4. UBF Documentation"><div class="titlepage"><div><div><h3 class="title"><a id="UBFAsciiDoc"></a>10.4. UBF Documentation</h3></div></div></div><p>This section is the first step to download and to build your own
UBF documentation.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
Building UBF’s "Guides" <span class="emphasis"><em>basic recipe</em></span>
</p><pre class="screen">$ cd working-directory-name/deps/ubf/priv/doc/src/ubf
$ make clean -OR- make realclean
$ make</pre></li><li class="listitem"><p class="simpara">
Building UBF’s "Website" <span class="emphasis"><em>basic recipe</em></span>
</p><pre class="screen">$ cd working-directory-name/deps/ubf/priv/doc/src/ubf/website
$ make clean -OR- make realclean
$ make</pre><div class="note" title="Note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>HTML documentation is written in the "./public_html" directory.</p></td></tr></table></div></li></ol></div><p>UBF’s documentation is authored using AsciiDoc and a few auxillary
tools:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
ImageMagick
</li><li class="listitem">
dblatex
</li><li class="listitem">
Dia
</li><li class="listitem">
Graphviz
</li><li class="listitem">
Mscgen
</li><li class="listitem">
w3m
</li></ul></div><p>UBF’s documentation is generated with AsciiDoc and a manually modified
version of the a2x tool.  A fake lang-ja.conf file can be easily
created by making a symlink to the lang-en.conf file.</p><pre class="screen">diff -r -u 8.6.4-orig/bin/a2x.py 8.6.4/bin/a2x.py
--- 8.6.4-orig/bin/a2x.py       2011-04-24 00:50:26.000000000 +0900
+++ 8.6.4/bin/a2x.py    2011-04-24 00:35:55.000000000 +0900
@@ -156,7 +156,10 @@
 def shell_copy(src, dst):
     verbose('copying "%s" to "%s"' % (src,dst))
     if not OPTIONS.dry_run:
-        shutil.copy(src, dst)
+        try:
+            shutil.copy(src, dst)
+        except shutil.Error:
+            return

 def shell_rm(path):
     if not os.path.exists(path):
Only in 8.6.4/etc/asciidoc: lang-ja.conf</pre></div><div class="section" title="10.5. Erlang/OTP System"><div class="titlepage"><div><div><h3 class="title"><a id="ErlangOTP"></a>10.5. Erlang/OTP System</h3></div></div></div><p>This section is the first step to download, to build, and to install
your own Erlang/OTP system.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
Downloading <span class="emphasis"><em>basic recipe</em></span>
</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
Get and install Git
</li><li class="listitem"><p class="simpara">
Download the source code for your Erlang/OTP system
</p><pre class="screen">$ cd working-directory-name
$ wget http://www.erlang.org/download/otp_src_R15B.tar.gz</pre></li><li class="listitem"><p class="simpara">
Untar the source code for your Erlang/OTP system.
</p><pre class="screen">$ cd working-directory-name
$ tar -xzf otp_src_R15B.tar.gz</pre></li></ol></div></li><li class="listitem"><p class="simpara">
Building <span class="emphasis"><em>basic recipe</em></span>
</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
Change to your working directory and configure Erlang/OTP
</p><pre class="screen">$ cd working-directory-name/otp_src_R15B
$ ./configure --prefix=otp-installing-directory-name</pre></li><li class="listitem"><p class="simpara">
Build Erlang/OTP
</p><pre class="screen">$ cd working-directory-name/otp_src_R15B
$ make</pre></li></ol></div></li><li class="listitem"><p class="simpara">
Installing <span class="emphasis"><em>basic recipe</em></span>
</p><pre class="screen">$ cd working-directory-name/otp_src_R15B
$ sudo make install</pre></li></ol></div><div class="caution" title="Caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Please make sure "otp-installing-directory-name/bin" is added
to your $PATH environment.</p></td></tr></table></div></div><div class="section" title="10.6. GitHub - Forking Your Own Repositories"><div class="titlepage"><div><div><h3 class="title"><a id="_github_forking_your_own_repositories"></a>10.6. GitHub - Forking Your Own Repositories</h3></div></div></div><p>If you are interested in making your own changes to UBF or to one or
more of the other UBF-related repositories, it is a straigthforward
process to fork and to build your own repositories using <a class="xref" href="#GITHUB">[GITHUB]</a>.
GitHub provides a friendly and easy to use environment for developers
and the like.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
If you haven’t already done so, create your own account on GitHub
   and setup access with your public ssh key.  Next using your web
   browser, login as yourself to GitHub.
</li><li class="listitem">
Choose all or a subset of the UBF-related repositories that you are
   interested in forking.  For the sake of an example, let’s choose
   the <span class="emphasis"><em>ubf-bertrpc</em></span> repository and open the front page of this
   repository <a class="xref" href="#UBF_BERTRPC">[UBF_BERTRPC]</a> using your web browser.
</li><li class="listitem">
Click on the "Fork" button near the top of the page.  This action
   creates a clone of the <span class="emphasis"><em>ubf-bertrpc</em></span> repository in your own account
   on GitHub.
</li></ol></div><p><span class="emphasis"><em>Under Construction - To Be Updated</em></span></p><p></p></div></div><div class="section" title="11. Reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_reference"></a>11. Reference</h2></div></div></div><div class="bibliodiv" title="Optional list title"><h3 class="title"><a id="idp10336080"></a>Optional list title</h3><div class="bibliomixed"><a id="idp10336592"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="AVRO"></a>[AVRO] "Avro is a serialization system.",
  <a class="ulink" href="http://avro.apache.org" target="_top">http://avro.apache.org</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10338768"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="BERTRPC"></a>[BERTRPC] "BERT and BERT-RPC 1.0 Specification",
  <a class="ulink" href="http://bert-rpc.org" target="_top">http://bert-rpc.org</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10340960"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="ERLANG"></a>[ERLANG] "A general-purpose programming language and runtime
  environment", <a class="ulink" href="http://www.erlang.org" target="_top">http://www.erlang.org</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10343200"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="GIT"></a>[GIT] "Fast Version Control System", <a class="ulink" href="http://git-scm.com" target="_top">http://git-scm.com</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10345280"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="JSFCHARSET"></a>[JSFCHARSET] "Gemini Mobile Technologies, Inc. charset module",
  <a class="ulink" href="https://github.com/ubf/ubf-jsonrpc/blob/master/src/jsf_charset.erl" target="_top">https://github.com/ubf/ubf-jsonrpc/blob/master/src/jsf_charset.erl</a>
</span>
</p></div><div class="bibliomixed"><a id="idp10347664"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="GITHUB"></a>[GITHUB] "Secure source code hosting and collaborative
  development ", <a class="ulink" href="https://github.com" target="_top">https://github.com</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10349904"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="JSONRPC"></a>[JSONRPC] "A lightweight remote procedure call protocol similar
  to XML-RPC", <a class="ulink" href="http://json-rpc.org" target="_top">http://json-rpc.org</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10352144"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="MOCHIJSON2"></a>[MOCHIJSON2] "MochiWeb is an Erlang library for building
  lightweight HTTP servers.",
  <a class="ulink" href="https://github.com/mochi/mochiweb/blob/master/src/mochijson2.erl" target="_top">https://github.com/mochi/mochiweb/blob/master/src/mochijson2.erl</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10354560"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="PROTOBUF"></a>[PROTOBUF] "Protocol buffers are Google’s language-neutral,
  platform-neutral, extensible mechanism for serializing structured
  data.", <a class="ulink" href="http://code.google.com/apis/protocolbuffers" target="_top">http://code.google.com/apis/protocolbuffers</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10356960"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="QUVIQ"></a>[QUVIQ] "Quviq … amazing testing tools",
  <a class="ulink" href="http://www.quviq.com/" target="_top">http://www.quviq.com/</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10359168"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="RFC20"></a>[RFC20] Vint Cerf, "ASCII format for Network Interchange",
  RFC20, October 16, 1969.
</span>
</p></div><div class="bibliomixed"><a id="idp10360816"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="RFC4627"></a>[RFC4627] D. Crockford, "The application/json Media Type for
  JavaScript Object Notation (JSON)", RFC4627, July 2006.
</span>
</p></div><div class="bibliomixed"><a id="idp10362528"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="RFC5234"></a>[RFC5234] D. Crocker, Ed. Brandenburg, "Augmented BNF for Syntax
  Specifications: ABNF", RFC5234, January 2008.
</span>
</p></div><div class="bibliomixed"><a id="idp10364320"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="THRIFT"></a>[THRIFT] "A software framework for scalable cross-language
  services development.", <a class="ulink" href="http://incubator.apache.org/thrift" target="_top">http://incubator.apache.org/thrift</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10366576"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="UBF"></a>[UBF] "Universal Binary Format", <a class="ulink" href="https://github.com/ubf/ubf" target="_top">https://github.com/ubf/ubf</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10368656"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="UBF_ABNF"></a>[UBF_ABNF] "Universal Binary Format and Augmented Backus-Naur
  Form", <a class="ulink" href="https://github.com/ubf/ubf-abnf" target="_top">https://github.com/ubf/ubf-abnf</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10370880"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="UBF_BERTRPC"></a>[UBF_BERTRPC] "Universal Binary Format and Binary ERlang Term
  RPC", <a class="ulink" href="https://github.com/ubf/ubf-bertrpc" target="_top">https://github.com/ubf/ubf-bertrpc</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10373104"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="UBF_EEP8"></a>[UBF_EEP8] "Universal Binary Format and Erlang Enhancement
  Proposal 8", <a class="ulink" href="https://github.com/ubf/ubf-eep8" target="_top">https://github.com/ubf/ubf-eep8</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10375344"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="UBF_JSONRPC"></a>[UBF_JSONRPC] "Universal Binary Format and JavaScript Object
  Notation RPC", <a class="ulink" href="https://github.com/ubf/ubf-jsonrpc" target="_top">https://github.com/ubf/ubf-jsonrpc</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10377584"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="UBF_THRIFT"></a>[UBF_THRIFT] "Universal Binary Format and Thrift",
  <a class="ulink" href="https://github.com/ubf/ubf-thrift" target="_top">https://github.com/ubf/ubf-thrift</a>.
</span>
</p></div><div class="bibliomixed"><a id="idp10379776"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="UBFPAPER"></a>[UBFPAPER] Joe Armstrong, "Getting Erlang to talk to the outside
  world", Proceedings of the 2002 ACM SIGPLAN workshop on Erlang,
  pages 64-72, ACM Press, 2002.
</span>
</p></div><div class="bibliomixed"><a id="idp10381520"></a><p class="bibliomixed">
<span class="bibliomisc">
<a id="UBFSITE"></a>[UBFSITE] Joe Armstrong,
  <a class="ulink" href="http://www.sics.se/~joe/ubf/site/home.html" target="_top">http://www.sics.se/~joe/ubf/site/home.html</a>, March 2003.
</span>
</p></div></div><p></p></div><div class="section" title="12. Appendix"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_appendix"></a>12. Appendix</h2></div></div></div><div class="section" title="12.1. Acknowledgments"><div class="titlepage"><div><div><h3 class="title"><a id="_acknowledgments"></a>12.1. Acknowledgments</h3></div></div></div><p>Many, many thanks to Joe Armstrong, UBF’s designer and original
implementor.</p><p>Gemini Mobile Technologies, Inc. has approved the release of its
extensions, improvements, etc. under an MIT license.  Joe Armstrong
has also given his blessing to Gemini’s license choice.</p><pre class="screen">The MIT License

Copyright (c) 2009-2011 Gemini Mobile Technologies, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.</pre><p></p></div><div class="section" title="12.2. ABNF Definition"><div class="titlepage"><div><div><h3 class="title"><a id="_abnf_definition"></a>12.2. ABNF Definition</h3></div></div></div><p>The formal syntax for UBF(a), UBF(b), and UBF(c) is defined in ABNF
format per <a class="xref" href="#RFC5234">[RFC5234]</a> except for one extension - single quoted
strings are case-sensitive.</p><div class="section" title="UBF(a)"><div class="titlepage"><div><div><h4 class="title"><a id="ABNF-UBFa"></a>UBF(a)</h4></div></div></div><pre class="programlisting">ubf-a          = *ubf-a-wsp ubf-a-object *ubf-a-wsp "$"

ubf-a-object   = (ubf-a-term / ubf-a-pop / ubf-a-push) *ubf-a-wsp [ubf-a-tag] *ubf-a-wsp

ubf-a-wsp      = ubf-a-comment / ubf-a-ignore

ubf-a-term     = ubf-a-atom
               / ubf-a-string
               / ubf-a-binary
               / ubf-a-integer
               / ubf-a-list
               / ubf-a-tuple

ubf-a-pop      = "&gt;" ubf-a-register

ubf-a-push     = ubf-a-register

ubf-a-atom     = "'" *(%x20-26 / %x28-5B / %x5D-7E / "\\" / "\'") "'"

ubf-a-string   = '"' *(%x20-21 / %x23-5B / %x5D-7E / '\\' / '\"') '"'

ubf-a-binary   = ubf-a-integer *ubf-a-wsp "~" *OCTET "~"

ubf-a-integer  = ["-"] 1*DIGIT

ubf-a-list     = "#" *ubf-a-wsp [ubf-a-object *ubf-a-wsp "&amp;"]

ubf-a-tuple    = "{" *ubf-a-wsp [ubf-a-object *ubf-a-wsp] "}"

ubf-a-tag      = "`" 1*(%x20-5B / %x5D-5F / %x61-7E / "\\" / "\`") "`"

ubf-a-comment  = "%" *(%x20-24 / %x26-5B / %x5D-7E / "\\" / "\%") "%"

ubf-a-ignore   = SP    ;; %x20
               / LF    ;; %x0A
               / CR    ;; %x0D
               / HTAB  ;; %x09
               / ","   ;; %x2C

ubf-a-control  = "%"   ;; %x25
               / '"'   ;; %x22
               / "~"   ;; %x7E
               / "'"   ;; %x27
               / "`"   ;; %x60
               / "{"   ;; %x7B
               / "}"   ;; %x7D
               / "#"   ;; %x23
               / "&amp;"   ;; %x26
               / "-"   ;; %x2D
               / DIGIT ;; %x30-39
               / ubf-a-ignore

ubf-a-register = %x21  ;; any octet except ubf-a-control
               / %x00-08
               / %x0B-0C
               / %x0E-1F
               / %x23-24
               / %x28-2B
               / %x2F
               / %x3A-5F
               / %x61-7A
               / %x7C
               / %x7F</pre></div><div class="section" title="UBF(b)"><div class="titlepage"><div><div><h4 class="title"><a id="ABNF-UBFb"></a>UBF(b)</h4></div></div></div><pre class="programlisting">ubf-b          = ubf-b-name ubf-b-vsn [ubf-b-type] *ubf-b-state [ubf-b-anystate]

ubf-b-name     = "+" 'NAME' "(" NONEMTPYSTRING ")" dot
ubf-b-vsn      = "+" 'VSN' "(" NONEMTPYSTRING ")" dot
ubf-b-type     = "+" 'TYPES' 1*WSP types dot
ubf-b-state    = "+" 'STATE' 1*WSP statename 1*WSP transitions dot
ubf-b-anystate = "+" 'ANYSTATE' 1*WSP anyrules dot

dot            = "." *c-wsp c-nl
semi           = ";" *c-wsp c-nl
comment        = "%" *(WSP / VCHAR) CRLF
c-nl           = comment / CRLF
c-wsp          = WSP / (c-nl WSP)

statename      = NONEMTPYATOM
typename       = NONEMTPYATOM
recordname     = NONEMTPYATOM
fieldname      = NONEMTPYATOM

types          = typedef
               / (typedef semi types)

typedef        = typeref *c-wsp "=" *c-wsp type [1*WSP annotation] *c-wsp

transitions    = transition
               / (transition semi transitions)

transition     = typeref *c-wsp "=&gt;" *c-wsp outputs *c-wsp
               / event

anyrules       = anyrule
               / (anyrule semi anyrules)

anyrule        = typeref *c-wsp "=&gt;" *c-wsp typeref *c-wsp
               / event

event          = 'EVENT' *c-wsp ("=&gt;" / "&lt;=") *c-wsp typeref *c-wsp

type           = primtype
               / (primtype *c-wsp "|" *c-wsp type)

annotation     = TAG / STRING / BINARY

outputs        = output
               / (output *c-wsp "|" *c-wsp outputs)

output         = typeref *c-wsp "&amp;" *c-wsp statename

primtype       = (typeref [ "?" ])
               / ("{" [typeseq] "}")
               / ("#" recordname "{" [typerec] "}")
               / ("##" recordname "{" [typerec] "}")
               / typelist
               / (INTEGER *WSP ".." *WSP INTEGER)
               / (".." *WSP INTEGER)
               / (INTEGER *WSP "..")
               / ATOM
               / BINARY
               / FLOAT
               / INTEGER
               / STRING
               / (predefinedtype [ "?" ])

typelist       = ("[" [type] "]" [ "?" / "+" / ("{" listrange "}") ])

typeref        = typename "()"

typeseq        = type
               / (type *WSP "," *WSP typeseq)

typerec        = (fieldname *WSP "=" *WSP type)
               / (fieldname *WSP "=" *WSP type "," *WSP typerec)

listrange      = (1*DIGIT)
               / (1*DIGIT *WSP ",")
               / (1*DIGIT *WSP "," *WSP 1*DIGIT)

ATOM           = (%x61-7A *(ALPHA / DIGIT / "_" / "@")) ;; a-z
               / ("'" *(%x20-26 / %x28-7E) "'")

NONEMTPYATOM   = (%x61-7A 1*(ALPHA / DIGIT / "_" / "@")) ;; a-z
               / ("'" 1*(%x20-26 / %x28-7E) "'")

BINARY         = "&lt;&lt;" STRING "&gt;&gt;"

FLOAT          = ["-"] 1*DIGIT "." 1*DIGIT

INTEGER        = (["-"] 1*DIGIT)
               / (1*DIGIT "#" 1*(DIGIT / 'a' / 'b' / 'c' / 'd' / 'e' / 'f'))

BTICK          = %x60

TAG            = BTICK *(%x20-5F / %x61-7E) BTICK

STRING         = DQUOTE *(%x20-21 / %x23-7E) DQUOTE

NONEMTPYSTRING = DQUOTE 1*(%x20-21 / %x23-7E) DQUOTE

predefinedtype = ('atom' "(" [atomattrs] ")")
               / ('binary' "(" [binaryattrs] ")")
               / ('float' "(" [floatattrs] ")")
               / ('integer' "(" [integerattrs] ")")
               / ('list' "(" [listattrs] ")")
               / ('proplist' "(" [proplistattrs] ")")
               / ('string' "(" [stringattrs] ")")
               / ('term' "(" [termattrs] ")")
               / ('tuple' "(" [tupleattrs] ")")
               / ('void' "(" [voidattrs] ")")

atomattrs      = atomattr
               / (atomattr *WSP "," *WSP atomattrs)

binaryattrs    = binaryattr
               / (binaryattr *WSP "," *WSP binaryattrs)

floatattrs     = *WSP

integerattrs   = *WSP

listattrs      = listattr
               / (listattr *WSP "," *WSP listattrs)

proplistattrs  = proplistattr
               / (proplistattr *WSP "," *WSP proplistattrs)

stringattrs    = stringattr
               / (stringattr *WSP "," *WSP stringattrs)

termattrs      = termattr
               / (termattr *WSP "," *WSP termattrs)

tupleattrs     = tupleattr
               / (tupleattr *WSP "," *WSP tupleattrs)

voidattrs      = *WSP

atomattr       = 'ascii' / 'asciiprintable' / 'nonempty' / 'nonundefined'
binaryattr     = 'ascii' / 'asciiprintable' / 'nonempty'
listattr       = 'nonempty'
proplistattr   = 'nonempty'
stringattr     = 'ascii' / 'asciiprintable' / 'nonempty'
termattr       = 'nonempty' / 'nonundefined'
tupleattr      = 'nonempty' / 'nonundefined'</pre></div><div class="section" title="UBF(c)"><div class="titlepage"><div><div><h4 class="title"><a id="ABNF-UBFc"></a>UBF(c)</h4></div></div></div><pre class="programlisting">ubf-c           = ubf-c-rpc-req
                / ubf-c-rpc-res
                / ubf-c-event-in
                / ubf-c-event-out

ubf-c-rpc-req   = ubf-msg "$"

ubf-c-rpc-res   = "{" (ubf-msg / ubf-error) "," ubf-nextstate "}" "$"

ubf-c-event-in  = "{" 'event_in' "," ubf-msg "}" "$"

ubf-c-event-out = "{" 'event_out' "," ubf-msg "}" "$"

ubf-msg         = ubf-a-term

ubf-nextstate   = ubf-a-atom

ubf-error       = ubf-client-error
                / ubf-server-error

ubf-client-error = "{" 'clientBrokeContract' "," ubf-msg "," ubf-expects-in "}" "$"

ubf-server-error = "{" 'serverBrokeContract' "," ubf-msg "," ubf-expects-out "}" "$"

ubf-expects-in   = ubf-a-term  ;; list of acceptable input types (for debugging purposes)

ubf-expects-out  = ubf-a-term  ;; list of acceptable output types (for debugging purposes)</pre></div></div></div></div></body></html>
