test:ss() start server
test:test() run a test

<h3>Testing with telnet</h3>
<pre>
	telnet localhost 2000
	'info'$  ... replies with info


<h3>The *complete* callback structure</h3>

We assume that each service has one manager
and several handlers (one per session)

1) The server is started with  

	server:start(Port)

2) A plugin Mod is started with 

	server:register(Mod)

	This will spawn a master Pid that will be associated 	
	with Mod

	Mod:name()                 = the registration name
	Mod:managerStartState()    = inital data for the master
	contracts:getContract(Mod) = Contract

3) The client makes a connection with

	client:connect(Host, Port) -> {ok, Pid} | {error, timeout|socket}
	

The manager has a sincle variable State




When the manager starts with the call
	
+type Plugin:manager_start_state() -> ManagerState()

This happens once only and is expected to return a new global state
for the manager.

Every time a new client wants to start, the client
creates a connection and then evaluates:

client:startSession(Pid, Session, Args) -> {accept, Reply, State}
	                                |  {reject, Reason}

Here Session names the protocol - Args is passed to the manager for
the application.

At the server side

	Plugin:start_request(Service, Args, ManagerState) ->
		{accept, Reply, State1, 
			HandlerData, 
			HandlerContract,
			HandlerCallbackModule,
			HandlerMaster,
			ManagerState}
	|       {reject, Reason, managerState().

is called. The input args come from the client call. On return

	Reply          = a value to be passed back to the application
	State1         = the state of the protocol
	handlerState() = the initial state of the handler
	managerState() = the final state of the manager

	The messages
	
	{startRequest, Session, Args} 
	{startAccept, Reply, State}
	{startReject, Reason}

client:info(Pid) -> string().
client:description(Pid) -> string().
client:services(Pid) -> [string()].

can be issued at any time.

Client RPC are perfomed with

	client:rpc(Pid, Q) -> {reply, Val, State2} | {error, Why}

	The messages are

	{rpc, Q} -> {rpcReply, Val, State} | {rpcError, Why}

	The callbacks are

	Plugin:handle_rpc(State1, Q, handerState(), Env) ->
		{reply, Val, State2, Data2}

...

	Try this

	set the environment variable WHERE to $HOME

	./irc_server in one window

	./irc_client "luke" in window  1
	./irc_client "fred" in window  2

	Look in irc_clinet.erl
		irc_plugin.erl
		irc_plugin.con

	If it doesn't work the paths aren't picking up the code


        (mail me if you have problems with cc:joe.armstrong@telia.com)
