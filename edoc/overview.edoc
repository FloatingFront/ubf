
@author Joe Armstrong, Joe Norton, Scott Lystig Fritchie, and others
@copyright 2002 Joe Armstrong, see LICENSE file in source distribution.
@title UBF: Contract Checking for Network Protocols

@doc Please see the "<a href="../README">README</a>" file at the top
of the UBF source distribution for information on the following:

<ul>
<li> How to build the source  </li>
<li> Documentation -- Where should I start?  </li>
<li> What is UBF?  </li>
<li> What is EBF?  </li>
<li> What is JSF?  </li>
<li> What about JSON-RPC?  </li>
<li> What about ABNF?  </li>
<li> What about EEP8?  </li>
<li> To do (in short term)  </li>
<li> To do (in long term)  </li>
<li> Credits  </li>
</ul>

== Process Structure Diagram ==

<img src="../priv/doc/ubf-flow-01.png"></img>

== The UBF(C) Meta-Protocol ==

UBF(C) allows a single TCP listener socket to provide the services of
several UBF(B) contracts as a simple "multiplexer".  This feature can
be very useful in situations where network policy cannot allow
multiple TCP ports to be opened or exposed to the outside world.

After a UBF client connects to a UBF(B) contract-based server, usually
the first RPC call sent is the UBF(C) metaprotocol RPC
`startSession()'.  In the UBF(C) contract definition (see end of this
section for link), `startSession()' is defined as:

```
+STATE start
        startSession() => ok() & start
                       |  error() & start.

+TYPES
startSession()   = {startSession, string(), term()};
'''

The `string()' item in the 2nd tuple position is the name of the
contract to use for all subsequent RPC calls.

The `term()' item in the 3rd tuple position is an arbitrary term that
will be passed to the server's `handlerStart()' function (see callback
function details below).  This term may be used to initialize any
session-specific state with data that must be provided by the client.

All of the client code examples in the "<a
href="../src/Unit-Test-Files">../src/Unit-Test-Files</a> directory
(source files with a "_client.erl" suffix) use the `startSession()'
call, usually immediately after connection to the UBF server via
`ubf_client:connect()'.

See the
"<a href="../src/ubf_plugin_meta_server.con">../src/ubf_plugin_meta_server.con</a>"
contract file for the format specification of the UBF(C) meta-protocol.

== UBF Server Implementation Callback Functions ==

All UBF server implementations, regardless of the transport protocol
that is used "over the wire" to communicate with it, must implement
the following callback functions:

<ul>
<li> handlerStart/1 or handlerStart/2  </li>
<li> handlerRpc/4  </li>
<li> handlerStop/3  </li>
<li> managerStart/1  </li>
<li> managerRestart/2  </li>
<li> managerRpc/2  </li>
</ul>

=== handlerStart/{1,2} ===

```
handlerStart(ManagerProc::pid()) ->
    {accept, Reply::term(), none, StateData::term()} |
    {reject, Reply::term()}

handlerStart(Arg_From_UBF_Client::term(), ManagerProc::pid()) ->
    {accept, Reply::term(), StateName::atom(), StateData::term()} |
    {reject, Reply::term()}
'''

The `handlerStart/1' form is used for "stateless" flavor of UBF
server.  Armstrong's original UBF implementation was by definition
stateful, so this form was not present in the original implementation.
However, not all servers must maintain session state, so a stateless
type of connection can simplify the contract by omitting all state
transitions.

The `handlerStart/2' form is used for the "stateful" flavor of UBF
server.  Contacts of the stateful type must explicitly define all
protocol state transitions.

`Reply' is the term sent in reply to the client.  `StateName' is the
name of the initial UBF(B) contract state for the contract's state
machine.  `StateData' is an term that will be used for this protocol
session for subsequent callback calls, e.g. handlerRpc/{3,4}.

The callback functions of both "stateless" and "stateful" server types
have a StateData term associated with them.  This might seem confusing
at first.  The "less" and "full" in the words "stateless" and
"stateful" refer to the absense or presence (respectively) of states
in the UBF contract.  However, both types of servers can maintain any
per-connection state that they wish, using the `StateData' term.
Also, in the "stateful" case, any/all data from the
`Arg_From_UBF_Client' term can be added to the `StateData' term.

=== handlerRpc/{3,4} ===

```
handlerRpc(unused, RpcCall::term(), StateData::term()) ->
    {Reply::term(), unused, NewStateData::term()}

handlerRpc(StateName::atom(), RpcCall::term(), StateData::term(), Env::term()) ->
    {Reply::term(), NewStateName::atom(), NewStateData::term()} |
    {changeContract, Reply::term(), NewStateData::term(), HandlerMod::atom(),
     State2::term(), Data2::term(), ManagerPid::pid}
'''

This callback function is called in response to an RPC call by the
client.  The `handlerRpc/3' form is used by "stateless" UBF contracts;
`handlerRpc/4' form is used by "stateful" UBF contracts.

`Reply' is the term to return to the client.  `NewStateName' is the
name of the UBF(B) contract state name to advance to.  `NewStateData'
is the new state term for this protocol session for subsequent
callback calls, e.g. handlerStop/3.

=== handlerStop/3 ===

```
handlerStop(undefined, Reason::term(), StateData::term() ->
    void()

handlerStop(Env::term(), Reason::term(), StateData::term() ->
    void()
'''

Stop this protocol session.  The return value is ignored.

=== managerStart/1 ===

```
managerStart(Args::term()) ->
    {ok, State::term()}
'''

This callback is not required for UBF(B) "stateless" contracts.

=== managerRestart/2 ===

```
managerRestart(Args::term(), Manager::pid()) ->
    ok | {error, Reason::term()}
'''

This callback is not required for UBF(B) "stateless" contracts.

=== managerRpc/2 ===

```
managerRpc(Args::term(), State::term()) ->
    {Reply::term(), NewState::term()}
'''

This callback is not required for UBF(B) "stateless" contracts.

== Reference Documentation ==

Documentation for the UBF source code is an evolving
work-in-progress.  At the moment, the following source modules have
the most (and most helpful) documentation, see frame on left side of
your browser:

<ul>
<li> contracts, for functions to help figure out
     why the contract checker believes that your term breaks a contract.   </li>
<li> jsf, for the rules for mapping one type to another,
     e.g. Erlang -> JSON.</li>
<li> ubf, for UBF(A) protocol encoding/decoding.  </li>
<li> ubf_client, for creating a UBF(A)/EBF/JSF protocol client for an
     Erlang application   </li>
<li> ubf_server, for starting a new UBF contract-using server </li>
</ul>

The original Armstrong code was written without use of the OTP library
framework.  For eyes that are used to reading code modules based on
OTP's `supervisor' and `gen_server' behaviors, the source may require
a few extra seconds of study ... which (we hope) will be rewarding in
the end.

== Credits ==

Many, many thanks to Joe Armstrong, UBF's designer and original
implementor.

Gemini Mobile Technologies, Inc. has approved the release of its
extensions, improvements, etc. under an MIT license.  Joe Armstrong
has also given his blessing to Gemini's license choice.

The primary source repository for UBF can be found at:
   http://github.com/norton/ubf

